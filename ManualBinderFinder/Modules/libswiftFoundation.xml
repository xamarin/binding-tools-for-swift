<manualbinderfinder version="1.011" encoding="UTF - 8">
<Module name="libswiftFoundation">
	<Classes>
		<Class name="Foundation.Data.RangeReference">
			<Property>
				<name="count">
				<signature="var count: Int">
				<Static="False">
			</Property>
			<Property>
				<name="lowerBound">
				<signature="var lowerBound: Int">
				<Static="False">
			</Property>
			<Property>
				<name="range">
				<signature="var range: Swift.Range(Int)">
				<Static="False">
			</Property>
			<Property>
				<name="upperBound">
				<signature="var upperBound: Int">
				<Static="False">
			</Property>
		</Class>
		<Class name="Foundation.JSONDecoder">
			<Property>
				<name="dataDecodingStrategy">
				<signature="var dataDecodingStrategy: Foundation.JSONDecoder.DataDecodingStrategy">
				<Static="False">
			</Property>
			<Property>
				<name="dateDecodingStrategy">
				<signature="var dateDecodingStrategy: Foundation.JSONDecoder.DateDecodingStrategy">
				<Static="False">
			</Property>
			<Property>
				<name="keyDecodingStrategy">
				<signature="var keyDecodingStrategy: Foundation.JSONDecoder.KeyDecodingStrategy">
				<Static="False">
			</Property>
			<Property>
				<name="nonConformingFloatDecodingStrategy">
				<signature="var nonConformingFloatDecodingStrategy: Foundation.JSONDecoder.NonConformingFloatDecodingStrategy">
				<Static="False">
			</Property>
			<Property>
				<name="userInfo">
				<signature="var userInfo: Swift.Dictionary(Swift.CodingUserInfoKey, Swift.Any)">
				<Static="False">
			</Property>
			<Method>
				<name="decode">
				<signature="func decode(: Meta , from: Foundation.Data) -> Self">
				<isStatic="False">
				<returnType="(0,0)">
				<Parameters>
					<Parameter=": Meta ">
					<Parameter="from: Foundation.Data">
				</Parameters>
			</Method>
		</Class>
		<Class name="Foundation.JSONEncoder">
			<Property>
				<name="dataEncodingStrategy">
				<signature="var dataEncodingStrategy: Foundation.JSONEncoder.DataEncodingStrategy">
				<Static="False">
			</Property>
			<Property>
				<name="dateEncodingStrategy">
				<signature="var dateEncodingStrategy: Foundation.JSONEncoder.DateEncodingStrategy">
				<Static="False">
			</Property>
			<Property>
				<name="keyEncodingStrategy">
				<signature="var keyEncodingStrategy: Foundation.JSONEncoder.KeyEncodingStrategy">
				<Static="False">
			</Property>
			<Property>
				<name="nonConformingFloatEncodingStrategy">
				<signature="var nonConformingFloatEncodingStrategy: Foundation.JSONEncoder.NonConformingFloatEncodingStrategy">
				<Static="False">
			</Property>
			<Property>
				<name="outputFormatting">
				<signature="var outputFormatting: Foundation.JSONEncoder.OutputFormatting">
				<Static="False">
			</Property>
			<Property>
				<name="userInfo">
				<signature="var userInfo: Swift.Dictionary(Swift.CodingUserInfoKey, Swift.Any)">
				<Static="False">
			</Property>
			<Method>
				<name="encode">
				<signature="func encodeSelf -> Foundation.Data">
				<isStatic="False">
				<returnType="Foundation.Data">
				<Parameters>
				</Parameters>
			</Method>
		</Class>
		<Class name="Foundation.NSKeyValueObservation">
			<Method>
				<name="invalidate">
				<signature="func invalidate()">
				<isStatic="False">
				<returnType="()">
				<Parameters>
					<Parameter="">
				</Parameters>
			</Method>
		</Class>
		<Class name="Foundation.NSURL">
		</Class>
		<Class name="Foundation.PropertyListDecoder">
			<Property>
				<name="userInfo">
				<signature="var userInfo: Swift.Dictionary(Swift.CodingUserInfoKey, Swift.Any)">
				<Static="False">
			</Property>
		</Class>
		<Class name="Foundation.PropertyListEncoder">
			<Property>
				<name="userInfo">
				<signature="var userInfo: Swift.Dictionary(Swift.CodingUserInfoKey, Swift.Any)">
				<Static="False">
			</Property>
			<Method>
				<name="encode">
				<signature="func encodeSelf -> Foundation.Data">
				<isStatic="False">
				<returnType="Foundation.Data">
				<Parameters>
				</Parameters>
			</Method>
		</Class>
	</Classes>
	<Structs>
		<Struct name="CoreGraphics.CGAffineTransform">
		</Struct>
		<Struct name="CoreGraphics.CGFloat">
		</Struct>
		<Struct name="CoreGraphics.CGPoint">
		</Struct>
		<Struct name="CoreGraphics.CGRect">
		</Struct>
		<Struct name="CoreGraphics.CGSize">
		</Struct>
		<Struct name="CoreGraphics.CGVector">
		</Struct>
		<Struct name="Dispatch.DispatchData">
		</Struct>
		<Struct name="Dispatch.DispatchData">
			<Property>
				<name="endIndex">
				<signature="var endIndex: Int">
				<Static="False">
			</Property>
			<Property>
				<name="regions">
				<signature="var regions: Swift.CollectionOfOne(Dispatch.DispatchData)">
				<Static="False">
			</Property>
			<Property>
				<name="startIndex">
				<signature="var startIndex: Int">
				<Static="False">
			</Property>
			<Method>
				<name="withUnsafeBytes">
				<signature="func withUnsafeBytesSwift.UnsafeRawBufferPointer -> Self -> Self">
				<isStatic="False">
				<returnType="(0,0)">
				<Parameters>
				</Parameters>
			</Method>
		</Struct>
		<Struct name="Foundation.Calendar">
			<Property>
				<name="amSymbol">
				<signature="var amSymbol: Swift.String">
				<Static="False">
			</Property>
			<Property>
				<name="autoupdatingCurrent">
				<signature="static var autoupdatingCurrent: Foundation.Calendar">
				<Static="False">
			</Property>
			<Property>
				<name="current">
				<signature="static var current: Foundation.Calendar">
				<Static="False">
			</Property>
			<Property>
				<name="customMirror">
				<signature="var customMirror: Swift.Mirror">
				<Static="False">
			</Property>
			<Property>
				<name="debugDescription">
				<signature="var debugDescription: Swift.String">
				<Static="False">
			</Property>
			<Property>
				<name="description">
				<signature="var description: Swift.String">
				<Static="False">
			</Property>
			<Property>
				<name="eraSymbols">
				<signature="var eraSymbols: Swift.Array(Swift.String)">
				<Static="False">
			</Property>
			<Property>
				<name="firstWeekday">
				<signature="var firstWeekday: Int">
				<Static="False">
			</Property>
			<Property>
				<name="hashValue">
				<signature="var hashValue: Int">
				<Static="False">
			</Property>
			<Property>
				<name="identifier">
				<signature="var identifier: Foundation.Calendar.Identifier">
				<Static="False">
			</Property>
			<Property>
				<name="locale">
				<signature="var locale: Foundation.Locale?">
				<Static="False">
			</Property>
			<Property>
				<name="longEraSymbols">
				<signature="var longEraSymbols: Swift.Array(Swift.String)">
				<Static="False">
			</Property>
			<Property>
				<name="minimumDaysInFirstWeek">
				<signature="var minimumDaysInFirstWeek: Int">
				<Static="False">
			</Property>
			<Property>
				<name="monthSymbols">
				<signature="var monthSymbols: Swift.Array(Swift.String)">
				<Static="False">
			</Property>
			<Property>
				<name="pmSymbol">
				<signature="var pmSymbol: Swift.String">
				<Static="False">
			</Property>
			<Property>
				<name="quarterSymbols">
				<signature="var quarterSymbols: Swift.Array(Swift.String)">
				<Static="False">
			</Property>
			<Property>
				<name="shortMonthSymbols">
				<signature="var shortMonthSymbols: Swift.Array(Swift.String)">
				<Static="False">
			</Property>
			<Property>
				<name="shortQuarterSymbols">
				<signature="var shortQuarterSymbols: Swift.Array(Swift.String)">
				<Static="False">
			</Property>
			<Property>
				<name="shortStandaloneMonthSymbols">
				<signature="var shortStandaloneMonthSymbols: Swift.Array(Swift.String)">
				<Static="False">
			</Property>
			<Property>
				<name="shortStandaloneQuarterSymbols">
				<signature="var shortStandaloneQuarterSymbols: Swift.Array(Swift.String)">
				<Static="False">
			</Property>
			<Property>
				<name="shortStandaloneWeekdaySymbols">
				<signature="var shortStandaloneWeekdaySymbols: Swift.Array(Swift.String)">
				<Static="False">
			</Property>
			<Property>
				<name="shortWeekdaySymbols">
				<signature="var shortWeekdaySymbols: Swift.Array(Swift.String)">
				<Static="False">
			</Property>
			<Property>
				<name="standaloneMonthSymbols">
				<signature="var standaloneMonthSymbols: Swift.Array(Swift.String)">
				<Static="False">
			</Property>
			<Property>
				<name="standaloneQuarterSymbols">
				<signature="var standaloneQuarterSymbols: Swift.Array(Swift.String)">
				<Static="False">
			</Property>
			<Property>
				<name="standaloneWeekdaySymbols">
				<signature="var standaloneWeekdaySymbols: Swift.Array(Swift.String)">
				<Static="False">
			</Property>
			<Property>
				<name="timeZone">
				<signature="var timeZone: Foundation.TimeZone">
				<Static="False">
			</Property>
			<Property>
				<name="veryShortMonthSymbols">
				<signature="var veryShortMonthSymbols: Swift.Array(Swift.String)">
				<Static="False">
			</Property>
			<Property>
				<name="veryShortStandaloneMonthSymbols">
				<signature="var veryShortStandaloneMonthSymbols: Swift.Array(Swift.String)">
				<Static="False">
			</Property>
			<Property>
				<name="veryShortStandaloneWeekdaySymbols">
				<signature="var veryShortStandaloneWeekdaySymbols: Swift.Array(Swift.String)">
				<Static="False">
			</Property>
			<Property>
				<name="veryShortWeekdaySymbols">
				<signature="var veryShortWeekdaySymbols: Swift.Array(Swift.String)">
				<Static="False">
			</Property>
			<Property>
				<name="weekdaySymbols">
				<signature="var weekdaySymbols: Swift.Array(Swift.String)">
				<Static="False">
			</Property>
			<Method>
				<name="==">
				<signature="static func ==(Foundation.Calendar, Foundation.Calendar) -> Bool">
				<isStatic="True">
				<returnType="Bool">
				<Parameters>
					<Parameter="Foundation.Calendar">
					<Parameter="Foundation.Calendar">
				</Parameters>
			</Method>
			<Method>
				<name="compare">
				<signature="func compare(: Foundation.Date, to: Foundation.Date, toGranularity: Foundation.Calendar.Component) -> Foundation.NSComparisonResult">
				<isStatic="False">
				<returnType="Foundation.NSComparisonResult">
				<Parameters>
					<Parameter=": Foundation.Date">
					<Parameter="to: Foundation.Date">
					<Parameter="toGranularity: Foundation.Calendar.Component">
				</Parameters>
			</Method>
			<Method>
				<name="component">
				<signature="func component(: Foundation.Calendar.Component, from: Foundation.Date) -> Int">
				<isStatic="False">
				<returnType="Int">
				<Parameters>
					<Parameter=": Foundation.Calendar.Component">
					<Parameter="from: Foundation.Date">
				</Parameters>
			</Method>
			<Method>
				<name="components">
				<signature="func components(in: Foundation.TimeZone, from: Foundation.Date) -> Foundation.DateComponents">
				<isStatic="False">
				<returnType="Foundation.DateComponents">
				<Parameters>
					<Parameter="in: Foundation.TimeZone">
					<Parameter="from: Foundation.Date">
				</Parameters>
			</Method>
			<Method>
				<name="date">
				<signature="func date(bySettingHour: Int, minute: Int, second: Int, of: Foundation.Date, matchingPolicy: Foundation.Calendar.MatchingPolicy, repeatedTimePolicy: Foundation.Calendar.RepeatedTimePolicy, direction: Foundation.Calendar.SearchDirection) -> Foundation.Date?">
				<isStatic="False">
				<returnType="Swift.Optional<Foundation.Date>">
				<Parameters>
					<Parameter="bySettingHour: Int">
					<Parameter="minute: Int">
					<Parameter="second: Int">
					<Parameter="of: Foundation.Date">
					<Parameter="matchingPolicy: Foundation.Calendar.MatchingPolicy">
					<Parameter="repeatedTimePolicy: Foundation.Calendar.RepeatedTimePolicy">
					<Parameter="direction: Foundation.Calendar.SearchDirection">
				</Parameters>
			</Method>
			<Method>
				<name="dateComponents">
				<signature="func dateComponents(in: Foundation.TimeZone, from: Foundation.Date) -> Foundation.DateComponents">
				<isStatic="False">
				<returnType="Foundation.DateComponents">
				<Parameters>
					<Parameter="in: Foundation.TimeZone">
					<Parameter="from: Foundation.Date">
				</Parameters>
			</Method>
			<Method>
				<name="dateInterval">
				<signature="func dateInterval(of: Foundation.Calendar.Component, for: Foundation.Date) -> Foundation.DateInterval?">
				<isStatic="False">
				<returnType="Swift.Optional<Foundation.DateInterval>">
				<Parameters>
					<Parameter="of: Foundation.Calendar.Component">
					<Parameter="for: Foundation.Date">
				</Parameters>
			</Method>
			<Method>
				<name="dateIntervalOfWeekend">
				<signature="func dateIntervalOfWeekend(containing: Foundation.Date, start: Foundation.Date, interval: Double) -> Bool">
				<isStatic="False">
				<returnType="Bool">
				<Parameters>
					<Parameter="containing: Foundation.Date">
					<Parameter="start: Foundation.Date">
					<Parameter="interval: Double">
				</Parameters>
			</Method>
			<Method>
				<name="encode">
				<signature="func encode(to: Swift.Encoder)">
				<isStatic="False">
				<returnType="()">
				<Parameters>
					<Parameter="to: Swift.Encoder">
				</Parameters>
			</Method>
			<Method>
				<name="enumerateDates">
				<signature="func enumerateDates(startingAfter: Foundation.Date, matching: Foundation.DateComponents, matchingPolicy: Foundation.Calendar.MatchingPolicy, repeatedTimePolicy: Foundation.Calendar.RepeatedTimePolicy, direction: Foundation.Calendar.SearchDirection, using: (Foundation.Date?, Bool, Bool))">
				<isStatic="False">
				<returnType="()">
				<Parameters>
					<Parameter="startingAfter: Foundation.Date">
					<Parameter="matching: Foundation.DateComponents">
					<Parameter="matchingPolicy: Foundation.Calendar.MatchingPolicy">
					<Parameter="repeatedTimePolicy: Foundation.Calendar.RepeatedTimePolicy">
					<Parameter="direction: Foundation.Calendar.SearchDirection">
					<Parameter="using: (Foundation.Date?">
					<Parameter="Bool">
					<Parameter="Bool">
				</Parameters>
			</Method>
			<Method>
				<name="getEra">
				<signature="func getEra(: UnsafeMutablePointer(Int)>, yearForWeekOfYear: Swift.UnsafeMutablePointer(Int)>, weekOfYear: Swift.Optional(Swift.UnsafeMutablePointer(Int)), weekday: Swift.Optional(Swift.UnsafeMutablePointer(Int??, from: Foundation.Date)">
				<isStatic="False">
				<returnType="()">
				<Parameters>
					<Parameter=": UnsafeMutablePointer(Int">
				</Parameters>
			</Method>
			<Method>
				<name="getHour">
				<signature="func getHour(: UnsafeMutablePointer(Int)>, minute: Swift.UnsafeMutablePointer(Int)>, second: Swift.Optional(Swift.UnsafeMutablePointer(Int)), nanosecond: Swift.Optional(Swift.UnsafeMutablePointer(Int??, from: Foundation.Date)">
				<isStatic="False">
				<returnType="()">
				<Parameters>
					<Parameter=": UnsafeMutablePointer(Int">
				</Parameters>
			</Method>
			<Method>
				<name="hash">
				<signature="func hash(into: Swift.Hasher)">
				<isStatic="False">
				<returnType="()">
				<Parameters>
					<Parameter="into: Swift.Hasher">
				</Parameters>
			</Method>
			<Method>
				<name="isDate">
				<signature="func isDate(: Foundation.Date, inSameDayAs: Foundation.Date) -> Bool">
				<isStatic="False">
				<returnType="Bool">
				<Parameters>
					<Parameter=": Foundation.Date">
					<Parameter="inSameDayAs: Foundation.Date">
				</Parameters>
			</Method>
			<Method>
				<name="isDateInToday">
				<signature="func isDateInTodayFoundation.Date -> Bool">
				<isStatic="False">
				<returnType="Bool">
				<Parameters>
				</Parameters>
			</Method>
			<Method>
				<name="isDateInTomorrow">
				<signature="func isDateInTomorrowFoundation.Date -> Bool">
				<isStatic="False">
				<returnType="Bool">
				<Parameters>
				</Parameters>
			</Method>
			<Method>
				<name="isDateInWeekend">
				<signature="func isDateInWeekendFoundation.Date -> Bool">
				<isStatic="False">
				<returnType="Bool">
				<Parameters>
				</Parameters>
			</Method>
			<Method>
				<name="isDateInYesterday">
				<signature="func isDateInYesterdayFoundation.Date -> Bool">
				<isStatic="False">
				<returnType="Bool">
				<Parameters>
				</Parameters>
			</Method>
			<Method>
				<name="maximumRange">
				<signature="func maximumRange(of: Foundation.Calendar.Component) -> Range(Int)?">
				<isStatic="False">
				<returnType="Swift.Optional<Swift.Range<Int>>">
				<Parameters>
					<Parameter="of: Foundation.Calendar.Component">
				</Parameters>
			</Method>
			<Method>
				<name="minimumRange">
				<signature="func minimumRange(of: Foundation.Calendar.Component) -> Range(Int)?">
				<isStatic="False">
				<returnType="Swift.Optional<Swift.Range<Int>>">
				<Parameters>
					<Parameter="of: Foundation.Calendar.Component">
				</Parameters>
			</Method>
			<Method>
				<name="nextWeekend">
				<signature="func nextWeekend(startingAfter: Foundation.Date, start: Foundation.Date, interval: Double, direction: Foundation.Calendar.SearchDirection) -> Bool">
				<isStatic="False">
				<returnType="Bool">
				<Parameters>
					<Parameter="startingAfter: Foundation.Date">
					<Parameter="start: Foundation.Date">
					<Parameter="interval: Double">
					<Parameter="direction: Foundation.Calendar.SearchDirection">
				</Parameters>
			</Method>
			<Method>
				<name="ordinality">
				<signature="func ordinality(of: Foundation.Calendar.Component, in: Foundation.Calendar.Component, for: Foundation.Date) -> Int?">
				<isStatic="False">
				<returnType="Swift.Optional<Int>">
				<Parameters>
					<Parameter="of: Foundation.Calendar.Component">
					<Parameter="in: Foundation.Calendar.Component">
					<Parameter="for: Foundation.Date">
				</Parameters>
			</Method>
			<Method>
				<name="startOfDay">
				<signature="func startOfDay(for: Foundation.Date) -> Foundation.Date">
				<isStatic="False">
				<returnType="Foundation.Date">
				<Parameters>
					<Parameter="for: Foundation.Date">
				</Parameters>
			</Method>
		</Struct>
		<Struct name="Foundation.CharacterSet">
			<Property>
				<name="alphanumerics">
				<signature="static var alphanumerics: Foundation.CharacterSet">
				<Static="False">
			</Property>
			<Property>
				<name="bitmapRepresentation">
				<signature="var bitmapRepresentation: Foundation.Data">
				<Static="False">
			</Property>
			<Property>
				<name="capitalizedLetters">
				<signature="static var capitalizedLetters: Foundation.CharacterSet">
				<Static="False">
			</Property>
			<Property>
				<name="controlCharacters">
				<signature="static var controlCharacters: Foundation.CharacterSet">
				<Static="False">
			</Property>
			<Property>
				<name="debugDescription">
				<signature="var debugDescription: Swift.String">
				<Static="False">
			</Property>
			<Property>
				<name="decimalDigits">
				<signature="static var decimalDigits: Foundation.CharacterSet">
				<Static="False">
			</Property>
			<Property>
				<name="decomposables">
				<signature="static var decomposables: Foundation.CharacterSet">
				<Static="False">
			</Property>
			<Property>
				<name="description">
				<signature="var description: Swift.String">
				<Static="False">
			</Property>
			<Property>
				<name="hashValue">
				<signature="var hashValue: Int">
				<Static="False">
			</Property>
			<Property>
				<name="illegalCharacters">
				<signature="static var illegalCharacters: Foundation.CharacterSet">
				<Static="False">
			</Property>
			<Property>
				<name="inverted">
				<signature="var inverted: Foundation.CharacterSet">
				<Static="False">
			</Property>
			<Property>
				<name="letters">
				<signature="static var letters: Foundation.CharacterSet">
				<Static="False">
			</Property>
			<Property>
				<name="lowercaseLetters">
				<signature="static var lowercaseLetters: Foundation.CharacterSet">
				<Static="False">
			</Property>
			<Property>
				<name="newlines">
				<signature="static var newlines: Foundation.CharacterSet">
				<Static="False">
			</Property>
			<Property>
				<name="nonBaseCharacters">
				<signature="static var nonBaseCharacters: Foundation.CharacterSet">
				<Static="False">
			</Property>
			<Property>
				<name="punctuation">
				<signature="static var punctuation: Foundation.CharacterSet">
				<Static="False">
			</Property>
			<Property>
				<name="punctuationCharacters">
				<signature="static var punctuationCharacters: Foundation.CharacterSet">
				<Static="False">
			</Property>
			<Property>
				<name="symbols">
				<signature="static var symbols: Foundation.CharacterSet">
				<Static="False">
			</Property>
			<Property>
				<name="uppercaseLetters">
				<signature="static var uppercaseLetters: Foundation.CharacterSet">
				<Static="False">
			</Property>
			<Property>
				<name="urlFragmentAllowed">
				<signature="static var urlFragmentAllowed: Foundation.CharacterSet">
				<Static="False">
			</Property>
			<Property>
				<name="urlHostAllowed">
				<signature="static var urlHostAllowed: Foundation.CharacterSet">
				<Static="False">
			</Property>
			<Property>
				<name="urlPasswordAllowed">
				<signature="static var urlPasswordAllowed: Foundation.CharacterSet">
				<Static="False">
			</Property>
			<Property>
				<name="urlPathAllowed">
				<signature="static var urlPathAllowed: Foundation.CharacterSet">
				<Static="False">
			</Property>
			<Property>
				<name="urlQueryAllowed">
				<signature="static var urlQueryAllowed: Foundation.CharacterSet">
				<Static="False">
			</Property>
			<Property>
				<name="urlUserAllowed">
				<signature="static var urlUserAllowed: Foundation.CharacterSet">
				<Static="False">
			</Property>
			<Property>
				<name="whitespaces">
				<signature="static var whitespaces: Foundation.CharacterSet">
				<Static="False">
			</Property>
			<Property>
				<name="whitespacesAndNewlines">
				<signature="static var whitespacesAndNewlines: Foundation.CharacterSet">
				<Static="False">
			</Property>
			<Method>
				<name="==">
				<signature="static func ==(Foundation.CharacterSet, Foundation.CharacterSet) -> Bool">
				<isStatic="True">
				<returnType="Bool">
				<Parameters>
					<Parameter="Foundation.CharacterSet">
					<Parameter="Foundation.CharacterSet">
				</Parameters>
			</Method>
			<Method>
				<name="contains">
				<signature="func containsSwift.Unicode.Scalar -> Bool">
				<isStatic="False">
				<returnType="Bool">
				<Parameters>
				</Parameters>
			</Method>
			<Method>
				<name="encode">
				<signature="func encode(to: Swift.Encoder)">
				<isStatic="False">
				<returnType="()">
				<Parameters>
					<Parameter="to: Swift.Encoder">
				</Parameters>
			</Method>
			<Method>
				<name="formIntersection">
				<signature="func formIntersectionFoundation.CharacterSet">
				<isStatic="False">
				<returnType="()">
				<Parameters>
				</Parameters>
			</Method>
			<Method>
				<name="formSymmetricDifference">
				<signature="func formSymmetricDifferenceFoundation.CharacterSet">
				<isStatic="False">
				<returnType="()">
				<Parameters>
				</Parameters>
			</Method>
			<Method>
				<name="formUnion">
				<signature="func formUnionFoundation.CharacterSet">
				<isStatic="False">
				<returnType="()">
				<Parameters>
				</Parameters>
			</Method>
			<Method>
				<name="hasMember">
				<signature="func hasMember(inPlane: Swift.UInt8) -> Bool">
				<isStatic="False">
				<returnType="Bool">
				<Parameters>
					<Parameter="inPlane: Swift.UInt8">
				</Parameters>
			</Method>
			<Method>
				<name="hash">
				<signature="func hash(into: Swift.Hasher)">
				<isStatic="False">
				<returnType="()">
				<Parameters>
					<Parameter="into: Swift.Hasher">
				</Parameters>
			</Method>
			<Method>
				<name="insert">
				<signature="func insert(charactersIn: Swift.ClosedRange(Swift.Unicode.Scalar))">
				<isStatic="False">
				<returnType="()">
				<Parameters>
					<Parameter="charactersIn: Swift.ClosedRange(Swift.Unicode.Scalar">
				</Parameters>
			</Method>
			<Method>
				<name="intersection">
				<signature="func intersectionFoundation.CharacterSet -> Foundation.CharacterSet">
				<isStatic="False">
				<returnType="Foundation.CharacterSet">
				<Parameters>
				</Parameters>
			</Method>
			<Method>
				<name="invert">
				<signature="func invert()">
				<isStatic="False">
				<returnType="()">
				<Parameters>
					<Parameter="">
				</Parameters>
			</Method>
			<Method>
				<name="isSuperset">
				<signature="func isSuperset(of: Foundation.CharacterSet) -> Bool">
				<isStatic="False">
				<returnType="Bool">
				<Parameters>
					<Parameter="of: Foundation.CharacterSet">
				</Parameters>
			</Method>
			<Method>
				<name="remove">
				<signature="func remove(charactersIn: Swift.ClosedRange(Swift.Unicode.Scalar))">
				<isStatic="False">
				<returnType="()">
				<Parameters>
					<Parameter="charactersIn: Swift.ClosedRange(Swift.Unicode.Scalar">
				</Parameters>
			</Method>
			<Method>
				<name="subtract">
				<signature="func subtractFoundation.CharacterSet">
				<isStatic="False">
				<returnType="()">
				<Parameters>
				</Parameters>
			</Method>
			<Method>
				<name="subtracting">
				<signature="func subtractingFoundation.CharacterSet -> Foundation.CharacterSet">
				<isStatic="False">
				<returnType="Foundation.CharacterSet">
				<Parameters>
				</Parameters>
			</Method>
			<Method>
				<name="symmetricDifference">
				<signature="func symmetricDifferenceFoundation.CharacterSet -> Foundation.CharacterSet">
				<isStatic="False">
				<returnType="Foundation.CharacterSet">
				<Parameters>
				</Parameters>
			</Method>
			<Method>
				<name="union">
				<signature="func unionFoundation.CharacterSet -> Foundation.CharacterSet">
				<isStatic="False">
				<returnType="Foundation.CharacterSet">
				<Parameters>
				</Parameters>
			</Method>
			<Method>
				<name="update">
				<signature="func update(with: Swift.Unicode.Scalar) -> Unicode.Scalar?">
				<isStatic="False">
				<returnType="Swift.Optional<Swift.Unicode.Scalar>">
				<Parameters>
					<Parameter="with: Swift.Unicode.Scalar">
				</Parameters>
			</Method>
		</Struct>
		<Struct name="Foundation.CocoaError">
			<Property>
				<name="coderInvalidValue">
				<signature="static var coderInvalidValue: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="coderReadCorrupt">
				<signature="static var coderReadCorrupt: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="coderReadCorruptError">
				<signature="static var coderReadCorruptError: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="coderValueNotFound">
				<signature="static var coderValueNotFound: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="coderValueNotFoundError">
				<signature="static var coderValueNotFoundError: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="errorDomain">
				<signature="static var errorDomain: Swift.String">
				<Static="False">
			</Property>
			<Property>
				<name="executableArchitectureMismatch">
				<signature="static var executableArchitectureMismatch: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="executableArchitectureMismatchError">
				<signature="static var executableArchitectureMismatchError: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="executableLink">
				<signature="static var executableLink: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="executableLinkError">
				<signature="static var executableLinkError: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="executableLoad">
				<signature="static var executableLoad: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="executableLoadError">
				<signature="static var executableLoadError: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="executableNotLoadable">
				<signature="static var executableNotLoadable: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="executableNotLoadableError">
				<signature="static var executableNotLoadableError: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="executableRuntimeMismatch">
				<signature="static var executableRuntimeMismatch: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="executableRuntimeMismatchError">
				<signature="static var executableRuntimeMismatchError: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="featureUnsupported">
				<signature="static var featureUnsupported: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="featureUnsupportedError">
				<signature="static var featureUnsupportedError: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="fileLocking">
				<signature="static var fileLocking: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="fileLockingError">
				<signature="static var fileLockingError: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="fileManagerUnmountBusy">
				<signature="static var fileManagerUnmountBusy: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="fileManagerUnmountBusyError">
				<signature="static var fileManagerUnmountBusyError: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="fileManagerUnmountUnknown">
				<signature="static var fileManagerUnmountUnknown: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="fileManagerUnmountUnknownError">
				<signature="static var fileManagerUnmountUnknownError: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="fileNoSuchFile">
				<signature="static var fileNoSuchFile: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="fileNoSuchFileError">
				<signature="static var fileNoSuchFileError: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="filePath">
				<signature="var filePath: String?">
				<Static="False">
			</Property>
			<Property>
				<name="fileReadCorruptFile">
				<signature="static var fileReadCorruptFile: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="fileReadCorruptFileError">
				<signature="static var fileReadCorruptFileError: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="fileReadInapplicableStringEncoding">
				<signature="static var fileReadInapplicableStringEncoding: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="fileReadInapplicableStringEncodingError">
				<signature="static var fileReadInapplicableStringEncodingError: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="fileReadInvalidFileName">
				<signature="static var fileReadInvalidFileName: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="fileReadInvalidFileNameError">
				<signature="static var fileReadInvalidFileNameError: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="fileReadNoPermission">
				<signature="static var fileReadNoPermission: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="fileReadNoPermissionError">
				<signature="static var fileReadNoPermissionError: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="fileReadNoSuchFile">
				<signature="static var fileReadNoSuchFile: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="fileReadNoSuchFileError">
				<signature="static var fileReadNoSuchFileError: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="fileReadTooLarge">
				<signature="static var fileReadTooLarge: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="fileReadTooLargeError">
				<signature="static var fileReadTooLargeError: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="fileReadUnknown">
				<signature="static var fileReadUnknown: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="fileReadUnknownError">
				<signature="static var fileReadUnknownError: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="fileReadUnknownStringEncoding">
				<signature="static var fileReadUnknownStringEncoding: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="fileReadUnknownStringEncodingError">
				<signature="static var fileReadUnknownStringEncodingError: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="fileReadUnsupportedScheme">
				<signature="static var fileReadUnsupportedScheme: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="fileReadUnsupportedSchemeError">
				<signature="static var fileReadUnsupportedSchemeError: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="fileWriteFileExists">
				<signature="static var fileWriteFileExists: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="fileWriteFileExistsError">
				<signature="static var fileWriteFileExistsError: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="fileWriteInapplicableStringEncoding">
				<signature="static var fileWriteInapplicableStringEncoding: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="fileWriteInapplicableStringEncodingError">
				<signature="static var fileWriteInapplicableStringEncodingError: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="fileWriteInvalidFileName">
				<signature="static var fileWriteInvalidFileName: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="fileWriteInvalidFileNameError">
				<signature="static var fileWriteInvalidFileNameError: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="fileWriteNoPermission">
				<signature="static var fileWriteNoPermission: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="fileWriteNoPermissionError">
				<signature="static var fileWriteNoPermissionError: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="fileWriteOutOfSpace">
				<signature="static var fileWriteOutOfSpace: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="fileWriteOutOfSpaceError">
				<signature="static var fileWriteOutOfSpaceError: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="fileWriteUnknown">
				<signature="static var fileWriteUnknown: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="fileWriteUnknownError">
				<signature="static var fileWriteUnknownError: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="fileWriteUnsupportedScheme">
				<signature="static var fileWriteUnsupportedScheme: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="fileWriteUnsupportedSchemeError">
				<signature="static var fileWriteUnsupportedSchemeError: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="fileWriteVolumeReadOnly">
				<signature="static var fileWriteVolumeReadOnly: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="fileWriteVolumeReadOnlyError">
				<signature="static var fileWriteVolumeReadOnlyError: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="formatting">
				<signature="static var formatting: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="formattingError">
				<signature="static var formattingError: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="hashValue">
				<signature="var hashValue: Int">
				<Static="False">
			</Property>
			<Property>
				<name="isCoderError">
				<signature="var isCoderError: Bool">
				<Static="False">
			</Property>
			<Property>
				<name="isExecutableError">
				<signature="var isExecutableError: Bool">
				<Static="False">
			</Property>
			<Property>
				<name="isFileError">
				<signature="var isFileError: Bool">
				<Static="False">
			</Property>
			<Property>
				<name="isFormattingError">
				<signature="var isFormattingError: Bool">
				<Static="False">
			</Property>
			<Property>
				<name="isPropertyListError">
				<signature="var isPropertyListError: Bool">
				<Static="False">
			</Property>
			<Property>
				<name="isUbiquitousFileError">
				<signature="var isUbiquitousFileError: Bool">
				<Static="False">
			</Property>
			<Property>
				<name="isUserActivityError">
				<signature="var isUserActivityError: Bool">
				<Static="False">
			</Property>
			<Property>
				<name="isValidationError">
				<signature="var isValidationError: Bool">
				<Static="False">
			</Property>
			<Property>
				<name="isXPCConnectionError">
				<signature="var isXPCConnectionError: Bool">
				<Static="False">
			</Property>
			<Property>
				<name="keyValueValidation">
				<signature="static var keyValueValidation: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="keyValueValidationError">
				<signature="static var keyValueValidationError: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="propertyListReadCorrupt">
				<signature="static var propertyListReadCorrupt: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="propertyListReadCorruptError">
				<signature="static var propertyListReadCorruptError: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="propertyListReadStream">
				<signature="static var propertyListReadStream: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="propertyListReadStreamError">
				<signature="static var propertyListReadStreamError: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="propertyListReadUnknownVersion">
				<signature="static var propertyListReadUnknownVersion: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="propertyListReadUnknownVersionError">
				<signature="static var propertyListReadUnknownVersionError: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="propertyListWriteInvalid">
				<signature="static var propertyListWriteInvalid: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="propertyListWriteInvalidError">
				<signature="static var propertyListWriteInvalidError: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="propertyListWriteStream">
				<signature="static var propertyListWriteStream: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="propertyListWriteStreamError">
				<signature="static var propertyListWriteStreamError: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="stringEncoding">
				<signature="var stringEncoding: String?">
				<Static="False">
			</Property>
			<Property>
				<name="ubiquitousFileNotUploadedDueToQuota">
				<signature="static var ubiquitousFileNotUploadedDueToQuota: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="ubiquitousFileNotUploadedDueToQuotaError">
				<signature="static var ubiquitousFileNotUploadedDueToQuotaError: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="ubiquitousFileUbiquityServerNotAvailable">
				<signature="static var ubiquitousFileUbiquityServerNotAvailable: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="ubiquitousFileUnavailable">
				<signature="static var ubiquitousFileUnavailable: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="ubiquitousFileUnavailableError">
				<signature="static var ubiquitousFileUnavailableError: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="underlying">
				<signature="var underlying: Error?">
				<Static="False">
			</Property>
			<Property>
				<name="url">
				<signature="var url: Foundation.URL?">
				<Static="False">
			</Property>
			<Property>
				<name="userActivityConnectionUnavailable">
				<signature="static var userActivityConnectionUnavailable: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="userActivityConnectionUnavailableError">
				<signature="static var userActivityConnectionUnavailableError: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="userActivityHandoffFailed">
				<signature="static var userActivityHandoffFailed: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="userActivityHandoffFailedError">
				<signature="static var userActivityHandoffFailedError: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="userActivityHandoffUserInfoTooLarge">
				<signature="static var userActivityHandoffUserInfoTooLarge: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="userActivityHandoffUserInfoTooLargeError">
				<signature="static var userActivityHandoffUserInfoTooLargeError: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="userActivityRemoteApplicationTimedOut">
				<signature="static var userActivityRemoteApplicationTimedOut: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="userActivityRemoteApplicationTimedOutError">
				<signature="static var userActivityRemoteApplicationTimedOutError: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="userCancelled">
				<signature="static var userCancelled: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="userCancelledError">
				<signature="static var userCancelledError: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="xpcConnectionInterrupted">
				<signature="static var xpcConnectionInterrupted: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="xpcConnectionInvalid">
				<signature="static var xpcConnectionInvalid: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="xpcConnectionReplyInvalid">
				<signature="static var xpcConnectionReplyInvalid: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Method>
				<name="error">
				<signature="static func error(: Foundation.CocoaError.Code, userInfo: Dictionary(Swift.AnyHashable, Swift.Any)>, url: Foundation.URL?) -? Swift.Error">
				<isStatic="True">
				<returnType="Swift.Error">
				<Parameters>
					<Parameter=": Foundation.CocoaError.Code">
					<Parameter="userInfo: Dictionary(Swift.AnyHashable">
					<Parameter="Swift.Any">
				</Parameters>
			</Method>
		</Struct>
		<Struct name="Foundation.CocoaError.Code">
			<Property>
				<name="CoderReadCorruptError">
				<signature="static var CoderReadCorruptError: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="CoderValueNotFoundError">
				<signature="static var CoderValueNotFoundError: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="ExecutableArchitectureMismatchError">
				<signature="static var ExecutableArchitectureMismatchError: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="ExecutableLinkError">
				<signature="static var ExecutableLinkError: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="ExecutableLoadError">
				<signature="static var ExecutableLoadError: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="ExecutableNotLoadableError">
				<signature="static var ExecutableNotLoadableError: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="ExecutableRuntimeMismatchError">
				<signature="static var ExecutableRuntimeMismatchError: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="FeatureUnsupportedError">
				<signature="static var FeatureUnsupportedError: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="FileLockingError">
				<signature="static var FileLockingError: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="FileManagerUnmountBusyError">
				<signature="static var FileManagerUnmountBusyError: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="FileManagerUnmountUnknownError">
				<signature="static var FileManagerUnmountUnknownError: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="FileNoSuchFileError">
				<signature="static var FileNoSuchFileError: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="FileReadCorruptFileError">
				<signature="static var FileReadCorruptFileError: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="FileReadInapplicableStringEncodingError">
				<signature="static var FileReadInapplicableStringEncodingError: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="FileReadInvalidFileNameError">
				<signature="static var FileReadInvalidFileNameError: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="FileReadNoPermissionError">
				<signature="static var FileReadNoPermissionError: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="FileReadNoSuchFileError">
				<signature="static var FileReadNoSuchFileError: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="FileReadTooLargeError">
				<signature="static var FileReadTooLargeError: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="FileReadUnknownError">
				<signature="static var FileReadUnknownError: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="FileReadUnknownStringEncodingError">
				<signature="static var FileReadUnknownStringEncodingError: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="FileReadUnsupportedSchemeError">
				<signature="static var FileReadUnsupportedSchemeError: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="FileWriteFileExistsError">
				<signature="static var FileWriteFileExistsError: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="FileWriteInapplicableStringEncodingError">
				<signature="static var FileWriteInapplicableStringEncodingError: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="FileWriteInvalidFileNameError">
				<signature="static var FileWriteInvalidFileNameError: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="FileWriteNoPermissionError">
				<signature="static var FileWriteNoPermissionError: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="FileWriteOutOfSpaceError">
				<signature="static var FileWriteOutOfSpaceError: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="FileWriteUnknownError">
				<signature="static var FileWriteUnknownError: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="FileWriteUnsupportedSchemeError">
				<signature="static var FileWriteUnsupportedSchemeError: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="FileWriteVolumeReadOnlyError">
				<signature="static var FileWriteVolumeReadOnlyError: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="FormattingError">
				<signature="static var FormattingError: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="KeyValueValidationError">
				<signature="static var KeyValueValidationError: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="PropertyListReadCorruptError">
				<signature="static var PropertyListReadCorruptError: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="PropertyListReadStreamError">
				<signature="static var PropertyListReadStreamError: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="PropertyListReadUnknownVersionError">
				<signature="static var PropertyListReadUnknownVersionError: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="PropertyListWriteInvalidError">
				<signature="static var PropertyListWriteInvalidError: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="PropertyListWriteStreamError">
				<signature="static var PropertyListWriteStreamError: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="UbiquitousFileNotUploadedDueToQuotaError">
				<signature="static var UbiquitousFileNotUploadedDueToQuotaError: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="UbiquitousFileUbiquityServerNotAvailable">
				<signature="static var UbiquitousFileUbiquityServerNotAvailable: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="UbiquitousFileUnavailableError">
				<signature="static var UbiquitousFileUnavailableError: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="UserActivityConnectionUnavailableError">
				<signature="static var UserActivityConnectionUnavailableError: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="UserActivityHandoffFailedError">
				<signature="static var UserActivityHandoffFailedError: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="UserActivityHandoffUserInfoTooLargeError">
				<signature="static var UserActivityHandoffUserInfoTooLargeError: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="UserActivityRemoteApplicationTimedOutError">
				<signature="static var UserActivityRemoteApplicationTimedOutError: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="UserCancelledError">
				<signature="static var UserCancelledError: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="XPCConnectionInterrupted">
				<signature="static var XPCConnectionInterrupted: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="XPCConnectionInvalid">
				<signature="static var XPCConnectionInvalid: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="XPCConnectionReplyInvalid">
				<signature="static var XPCConnectionReplyInvalid: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="coderInvalidValue">
				<signature="static var coderInvalidValue: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="coderReadCorrupt">
				<signature="static var coderReadCorrupt: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="coderReadCorruptError">
				<signature="static var coderReadCorruptError: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="coderValueNotFound">
				<signature="static var coderValueNotFound: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="coderValueNotFoundError">
				<signature="static var coderValueNotFoundError: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="executableArchitectureMismatch">
				<signature="static var executableArchitectureMismatch: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="executableArchitectureMismatchError">
				<signature="static var executableArchitectureMismatchError: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="executableLink">
				<signature="static var executableLink: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="executableLinkError">
				<signature="static var executableLinkError: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="executableLoad">
				<signature="static var executableLoad: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="executableLoadError">
				<signature="static var executableLoadError: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="executableNotLoadable">
				<signature="static var executableNotLoadable: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="executableNotLoadableError">
				<signature="static var executableNotLoadableError: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="executableRuntimeMismatch">
				<signature="static var executableRuntimeMismatch: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="executableRuntimeMismatchError">
				<signature="static var executableRuntimeMismatchError: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="featureUnsupported">
				<signature="static var featureUnsupported: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="featureUnsupportedError">
				<signature="static var featureUnsupportedError: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="fileLocking">
				<signature="static var fileLocking: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="fileLockingError">
				<signature="static var fileLockingError: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="fileManagerUnmountBusy">
				<signature="static var fileManagerUnmountBusy: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="fileManagerUnmountBusyError">
				<signature="static var fileManagerUnmountBusyError: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="fileManagerUnmountUnknown">
				<signature="static var fileManagerUnmountUnknown: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="fileManagerUnmountUnknownError">
				<signature="static var fileManagerUnmountUnknownError: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="fileNoSuchFile">
				<signature="static var fileNoSuchFile: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="fileNoSuchFileError">
				<signature="static var fileNoSuchFileError: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="fileReadCorruptFile">
				<signature="static var fileReadCorruptFile: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="fileReadCorruptFileError">
				<signature="static var fileReadCorruptFileError: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="fileReadInapplicableStringEncoding">
				<signature="static var fileReadInapplicableStringEncoding: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="fileReadInapplicableStringEncodingError">
				<signature="static var fileReadInapplicableStringEncodingError: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="fileReadInvalidFileName">
				<signature="static var fileReadInvalidFileName: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="fileReadInvalidFileNameError">
				<signature="static var fileReadInvalidFileNameError: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="fileReadNoPermission">
				<signature="static var fileReadNoPermission: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="fileReadNoPermissionError">
				<signature="static var fileReadNoPermissionError: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="fileReadNoSuchFile">
				<signature="static var fileReadNoSuchFile: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="fileReadNoSuchFileError">
				<signature="static var fileReadNoSuchFileError: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="fileReadTooLarge">
				<signature="static var fileReadTooLarge: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="fileReadTooLargeError">
				<signature="static var fileReadTooLargeError: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="fileReadUnknown">
				<signature="static var fileReadUnknown: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="fileReadUnknownError">
				<signature="static var fileReadUnknownError: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="fileReadUnknownStringEncoding">
				<signature="static var fileReadUnknownStringEncoding: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="fileReadUnknownStringEncodingError">
				<signature="static var fileReadUnknownStringEncodingError: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="fileReadUnsupportedScheme">
				<signature="static var fileReadUnsupportedScheme: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="fileReadUnsupportedSchemeError">
				<signature="static var fileReadUnsupportedSchemeError: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="fileWriteFileExists">
				<signature="static var fileWriteFileExists: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="fileWriteFileExistsError">
				<signature="static var fileWriteFileExistsError: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="fileWriteInapplicableStringEncoding">
				<signature="static var fileWriteInapplicableStringEncoding: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="fileWriteInapplicableStringEncodingError">
				<signature="static var fileWriteInapplicableStringEncodingError: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="fileWriteInvalidFileName">
				<signature="static var fileWriteInvalidFileName: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="fileWriteInvalidFileNameError">
				<signature="static var fileWriteInvalidFileNameError: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="fileWriteNoPermission">
				<signature="static var fileWriteNoPermission: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="fileWriteNoPermissionError">
				<signature="static var fileWriteNoPermissionError: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="fileWriteOutOfSpace">
				<signature="static var fileWriteOutOfSpace: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="fileWriteOutOfSpaceError">
				<signature="static var fileWriteOutOfSpaceError: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="fileWriteUnknown">
				<signature="static var fileWriteUnknown: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="fileWriteUnknownError">
				<signature="static var fileWriteUnknownError: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="fileWriteUnsupportedScheme">
				<signature="static var fileWriteUnsupportedScheme: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="fileWriteUnsupportedSchemeError">
				<signature="static var fileWriteUnsupportedSchemeError: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="fileWriteVolumeReadOnly">
				<signature="static var fileWriteVolumeReadOnly: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="fileWriteVolumeReadOnlyError">
				<signature="static var fileWriteVolumeReadOnlyError: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="formatting">
				<signature="static var formatting: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="formattingError">
				<signature="static var formattingError: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="keyValueValidation">
				<signature="static var keyValueValidation: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="keyValueValidationError">
				<signature="static var keyValueValidationError: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="propertyListReadCorrupt">
				<signature="static var propertyListReadCorrupt: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="propertyListReadCorruptError">
				<signature="static var propertyListReadCorruptError: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="propertyListReadStream">
				<signature="static var propertyListReadStream: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="propertyListReadStreamError">
				<signature="static var propertyListReadStreamError: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="propertyListReadUnknownVersion">
				<signature="static var propertyListReadUnknownVersion: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="propertyListReadUnknownVersionError">
				<signature="static var propertyListReadUnknownVersionError: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="propertyListWriteInvalid">
				<signature="static var propertyListWriteInvalid: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="propertyListWriteInvalidError">
				<signature="static var propertyListWriteInvalidError: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="propertyListWriteStream">
				<signature="static var propertyListWriteStream: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="propertyListWriteStreamError">
				<signature="static var propertyListWriteStreamError: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="rawValue">
				<signature="var rawValue: Int">
				<Static="False">
			</Property>
			<Property>
				<name="ubiquitousFileNotUploadedDueToQuota">
				<signature="static var ubiquitousFileNotUploadedDueToQuota: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="ubiquitousFileNotUploadedDueToQuotaError">
				<signature="static var ubiquitousFileNotUploadedDueToQuotaError: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="ubiquitousFileUbiquityServerNotAvailable">
				<signature="static var ubiquitousFileUbiquityServerNotAvailable: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="ubiquitousFileUnavailable">
				<signature="static var ubiquitousFileUnavailable: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="ubiquitousFileUnavailableError">
				<signature="static var ubiquitousFileUnavailableError: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="userActivityConnectionUnavailable">
				<signature="static var userActivityConnectionUnavailable: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="userActivityConnectionUnavailableError">
				<signature="static var userActivityConnectionUnavailableError: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="userActivityHandoffFailed">
				<signature="static var userActivityHandoffFailed: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="userActivityHandoffFailedError">
				<signature="static var userActivityHandoffFailedError: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="userActivityHandoffUserInfoTooLarge">
				<signature="static var userActivityHandoffUserInfoTooLarge: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="userActivityHandoffUserInfoTooLargeError">
				<signature="static var userActivityHandoffUserInfoTooLargeError: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="userActivityRemoteApplicationTimedOut">
				<signature="static var userActivityRemoteApplicationTimedOut: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="userActivityRemoteApplicationTimedOutError">
				<signature="static var userActivityRemoteApplicationTimedOutError: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="userCancelled">
				<signature="static var userCancelled: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="userCancelledError">
				<signature="static var userCancelledError: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="xpcConnectionInterrupted">
				<signature="static var xpcConnectionInterrupted: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="xpcConnectionInvalid">
				<signature="static var xpcConnectionInvalid: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="xpcConnectionReplyInvalid">
				<signature="static var xpcConnectionReplyInvalid: Foundation.CocoaError.Code">
				<Static="False">
			</Property>
		</Struct>
		<Struct name="Foundation.Data">
			<Property>
				<name="bytes">
				<signature="var bytes: Swift.UnsafeRawPointer">
				<Static="False">
			</Property>
			<Property>
				<name="count">
				<signature="var count: Int">
				<Static="False">
			</Property>
			<Property>
				<name="customMirror">
				<signature="var customMirror: Swift.Mirror">
				<Static="False">
			</Property>
			<Property>
				<name="debugDescription">
				<signature="var debugDescription: Swift.String">
				<Static="False">
			</Property>
			<Property>
				<name="description">
				<signature="var description: Swift.String">
				<Static="False">
			</Property>
			<Property>
				<name="endIndex">
				<signature="var endIndex: Int">
				<Static="False">
			</Property>
			<Property>
				<name="hashValue">
				<signature="var hashValue: Int">
				<Static="False">
			</Property>
			<Property>
				<name="indices">
				<signature="var indices: Swift.Range(Int)">
				<Static="False">
			</Property>
			<Property>
				<name="length">
				<signature="var length: Int">
				<Static="False">
			</Property>
			<Property>
				<name="mutableBytes">
				<signature="var mutableBytes: Swift.UnsafeMutableRawPointer">
				<Static="False">
			</Property>
			<Property>
				<name="regions">
				<signature="var regions: Swift.CollectionOfOne(Foundation.Data)">
				<Static="False">
			</Property>
			<Property>
				<name="startIndex">
				<signature="var startIndex: Int">
				<Static="False">
			</Property>
			<Method>
				<name="==">
				<signature="static func ==(Foundation.Data, Foundation.Data) -> Bool">
				<isStatic="True">
				<returnType="Bool">
				<Parameters>
					<Parameter="Foundation.Data">
					<Parameter="Foundation.Data">
				</Parameters>
			</Method>
			<Method>
				<name="advanced">
				<signature="func advanced(by: Int) -> Foundation.Data">
				<isStatic="False">
				<returnType="Foundation.Data">
				<Parameters>
					<Parameter="by: Int">
				</Parameters>
			</Method>
			<Method>
				<name="append">
				<signature="func append(contentsOf: Swift.Array(Swift.UInt8))">
				<isStatic="False">
				<returnType="()">
				<Parameters>
					<Parameter="contentsOf: Swift.Array(Swift.UInt8">
				</Parameters>
			</Method>
			<Method>
				<name="copyBytes">
				<signature="func copyBytes(to: Swift.UnsafeMutableBufferPointer(Self), from: Range(Int)>) -? Int">
				<isStatic="False">
				<returnType="Int">
				<Parameters>
					<Parameter="to: Swift.UnsafeMutableBufferPointer(Self">
				</Parameters>
			</Method>
			<Method>
				<name="encode">
				<signature="func encode(to: Swift.Encoder)">
				<isStatic="False">
				<returnType="()">
				<Parameters>
					<Parameter="to: Swift.Encoder">
				</Parameters>
			</Method>
			<Method>
				<name="enumerateBytes">
				<signature="func enumerateBytes(Swift.UnsafeBufferPointer(Swift.UInt8), Int, Bool)">
				<isStatic="False">
				<returnType="()">
				<Parameters>
					<Parameter="Swift.UnsafeBufferPointer(Swift.UInt8">
				</Parameters>
			</Method>
			<Method>
				<name="hash">
				<signature="func hash(into: Swift.Hasher)">
				<isStatic="False">
				<returnType="()">
				<Parameters>
					<Parameter="into: Swift.Hasher">
				</Parameters>
			</Method>
			<Method>
				<name="index">
				<signature="func index(after: Int) -> Int">
				<isStatic="False">
				<returnType="Int">
				<Parameters>
					<Parameter="after: Int">
				</Parameters>
			</Method>
			<Method>
				<name="makeIterator">
				<signature="func makeIterator() -> Foundation.Data.Iterator">
				<isStatic="False">
				<returnType="Foundation.Data.Iterator">
				<Parameters>
					<Parameter="">
				</Parameters>
			</Method>
			<Method>
				<name="replaceSubrange">
				<signature="func replaceSubrange(: Swift.Range(Int), with: Swift.UnsafeRawPointer, count: Int)">
				<isStatic="False">
				<returnType="()">
				<Parameters>
					<Parameter=": Swift.Range(Int">
				</Parameters>
			</Method>
			<Method>
				<name="reserveCapacity">
				<signature="func reserveCapacityInt">
				<isStatic="False">
				<returnType="()">
				<Parameters>
				</Parameters>
			</Method>
			<Method>
				<name="resetBytes">
				<signature="func resetBytes(in: Swift.Range(Int))">
				<isStatic="False">
				<returnType="()">
				<Parameters>
					<Parameter="in: Swift.Range(Int">
				</Parameters>
			</Method>
			<Method>
				<name="subdata">
				<signature="func subdata(in: Swift.Range(Int)) -> Foundation.Data">
				<isStatic="False">
				<returnType="Foundation.Data">
				<Parameters>
					<Parameter="in: Swift.Range(Int">
				</Parameters>
			</Method>
			<Method>
				<name="withUnsafeBytes">
				<signature="func withUnsafeBytesSwift.UnsafePointer(???) -> Self -> Self">
				<isStatic="False">
				<returnType="(0,0)">
				<Parameters>
					<Parameter="???">
				</Parameters>
			</Method>
			<Method>
				<name="withUnsafeMutableBytes">
				<signature="func withUnsafeMutableBytesSwift.UnsafeMutablePointer(???) -> Self -> Self">
				<isStatic="False">
				<returnType="(0,0)">
				<Parameters>
					<Parameter="???">
				</Parameters>
			</Method>
		</Struct>
		<Struct name="Foundation.Data.InlineData">
			<Property>
				<name="bytes">
				<signature="var bytes: (Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8)">
				<Static="False">
			</Property>
			<Property>
				<name="capacity">
				<signature="var capacity: Int">
				<Static="False">
			</Property>
			<Property>
				<name="count">
				<signature="var count: Int">
				<Static="False">
			</Property>
			<Property>
				<name="endIndex">
				<signature="var endIndex: Int">
				<Static="False">
			</Property>
			<Property>
				<name="length">
				<signature="var length: Swift.UInt8">
				<Static="False">
			</Property>
			<Property>
				<name="startIndex">
				<signature="var startIndex: Int">
				<Static="False">
			</Property>
			<Method>
				<name="append">
				<signature="func append(contentsOf: Swift.UnsafeRawBufferPointer)">
				<isStatic="False">
				<returnType="()">
				<Parameters>
					<Parameter="contentsOf: Swift.UnsafeRawBufferPointer">
				</Parameters>
			</Method>
			<Method>
				<name="canStore">
				<signature="static func canStore(count: Int) -> Bool">
				<isStatic="True">
				<returnType="Bool">
				<Parameters>
					<Parameter="count: Int">
				</Parameters>
			</Method>
			<Method>
				<name="copyBytes">
				<signature="func copyBytes(to: Swift.UnsafeMutableRawPointer, from: Swift.Range(Int))">
				<isStatic="False">
				<returnType="()">
				<Parameters>
					<Parameter="to: Swift.UnsafeMutableRawPointer">
					<Parameter="from: Swift.Range(Int">
				</Parameters>
			</Method>
			<Method>
				<name="replaceSubrange">
				<signature="func replaceSubrange(: Swift.Range(Int), with: UnsafeRawPointer?, count: Int)">
				<isStatic="False">
				<returnType="()">
				<Parameters>
					<Parameter=": Swift.Range(Int">
				</Parameters>
			</Method>
			<Method>
				<name="resetBytes">
				<signature="func resetBytes(in: Swift.Range(Int))">
				<isStatic="False">
				<returnType="()">
				<Parameters>
					<Parameter="in: Swift.Range(Int">
				</Parameters>
			</Method>
			<Method>
				<name="withUnsafeBytes">
				<signature="func withUnsafeBytesSwift.UnsafeRawBufferPointer -> Self -> Self">
				<isStatic="False">
				<returnType="(0,0)">
				<Parameters>
				</Parameters>
			</Method>
			<Method>
				<name="withUnsafeMutableBytes">
				<signature="func withUnsafeMutableBytesSwift.UnsafeMutableRawBufferPointer -> Self -> Self">
				<isStatic="False">
				<returnType="(0,0)">
				<Parameters>
				</Parameters>
			</Method>
		</Struct>
		<Struct name="Foundation.Data.InlineSlice">
			<Property>
				<name="capacity">
				<signature="var capacity: Int">
				<Static="False">
			</Property>
			<Property>
				<name="count">
				<signature="var count: Int">
				<Static="False">
			</Property>
			<Property>
				<name="endIndex">
				<signature="var endIndex: Int">
				<Static="False">
			</Property>
			<Property>
				<name="range">
				<signature="var range: Swift.Range(Int)">
				<Static="False">
			</Property>
			<Property>
				<name="slice">
				<signature="var slice: Swift.Range(Swift.Int32)">
				<Static="False">
			</Property>
			<Property>
				<name="startIndex">
				<signature="var startIndex: Int">
				<Static="False">
			</Property>
			<Method>
				<name="append">
				<signature="func append(contentsOf: Swift.UnsafeRawBufferPointer)">
				<isStatic="False">
				<returnType="()">
				<Parameters>
					<Parameter="contentsOf: Swift.UnsafeRawBufferPointer">
				</Parameters>
			</Method>
			<Method>
				<name="canStore">
				<signature="static func canStore(count: Int) -> Bool">
				<isStatic="True">
				<returnType="Bool">
				<Parameters>
					<Parameter="count: Int">
				</Parameters>
			</Method>
			<Method>
				<name="copyBytes">
				<signature="func copyBytes(to: Swift.UnsafeMutableRawPointer, from: Swift.Range(Int))">
				<isStatic="False">
				<returnType="()">
				<Parameters>
					<Parameter="to: Swift.UnsafeMutableRawPointer">
					<Parameter="from: Swift.Range(Int">
				</Parameters>
			</Method>
			<Method>
				<name="ensureUniqueReference">
				<signature="func ensureUniqueReference()">
				<isStatic="False">
				<returnType="()">
				<Parameters>
					<Parameter="">
				</Parameters>
			</Method>
			<Method>
				<name="replaceSubrange">
				<signature="func replaceSubrange(: Swift.Range(Int), with: UnsafeRawPointer?, count: Int)">
				<isStatic="False">
				<returnType="()">
				<Parameters>
					<Parameter=": Swift.Range(Int">
				</Parameters>
			</Method>
			<Method>
				<name="reserveCapacity">
				<signature="func reserveCapacityInt">
				<isStatic="False">
				<returnType="()">
				<Parameters>
				</Parameters>
			</Method>
			<Method>
				<name="resetBytes">
				<signature="func resetBytes(in: Swift.Range(Int))">
				<isStatic="False">
				<returnType="()">
				<Parameters>
					<Parameter="in: Swift.Range(Int">
				</Parameters>
			</Method>
			<Method>
				<name="withUnsafeBytes">
				<signature="func withUnsafeBytesSwift.UnsafeRawBufferPointer -> Self -> Self">
				<isStatic="False">
				<returnType="(0,0)">
				<Parameters>
				</Parameters>
			</Method>
			<Method>
				<name="withUnsafeMutableBytes">
				<signature="func withUnsafeMutableBytesSwift.UnsafeMutableRawBufferPointer -> Self -> Self">
				<isStatic="False">
				<returnType="(0,0)">
				<Parameters>
				</Parameters>
			</Method>
		</Struct>
		<Struct name="Foundation.Data.Iterator">
			<Method>
				<name="next">
				<signature="func next() -> UInt8?">
				<isStatic="False">
				<returnType="Swift.Optional<Swift.UInt8>">
				<Parameters>
					<Parameter="">
				</Parameters>
			</Method>
		</Struct>
		<Struct name="Foundation.Data.LargeSlice">
			<Property>
				<name="capacity">
				<signature="var capacity: Int">
				<Static="False">
			</Property>
			<Property>
				<name="count">
				<signature="var count: Int">
				<Static="False">
			</Property>
			<Property>
				<name="endIndex">
				<signature="var endIndex: Int">
				<Static="False">
			</Property>
			<Property>
				<name="range">
				<signature="var range: Swift.Range(Int)">
				<Static="False">
			</Property>
			<Property>
				<name="slice">
				<signature="var slice: Foundation.Data.RangeReference">
				<Static="False">
			</Property>
			<Property>
				<name="startIndex">
				<signature="var startIndex: Int">
				<Static="False">
			</Property>
			<Method>
				<name="append">
				<signature="func append(contentsOf: Swift.UnsafeRawBufferPointer)">
				<isStatic="False">
				<returnType="()">
				<Parameters>
					<Parameter="contentsOf: Swift.UnsafeRawBufferPointer">
				</Parameters>
			</Method>
			<Method>
				<name="copyBytes">
				<signature="func copyBytes(to: Swift.UnsafeMutableRawPointer, from: Swift.Range(Int))">
				<isStatic="False">
				<returnType="()">
				<Parameters>
					<Parameter="to: Swift.UnsafeMutableRawPointer">
					<Parameter="from: Swift.Range(Int">
				</Parameters>
			</Method>
			<Method>
				<name="ensureUniqueReference">
				<signature="func ensureUniqueReference()">
				<isStatic="False">
				<returnType="()">
				<Parameters>
					<Parameter="">
				</Parameters>
			</Method>
			<Method>
				<name="replaceSubrange">
				<signature="func replaceSubrange(: Swift.Range(Int), with: UnsafeRawPointer?, count: Int)">
				<isStatic="False">
				<returnType="()">
				<Parameters>
					<Parameter=": Swift.Range(Int">
				</Parameters>
			</Method>
			<Method>
				<name="reserveCapacity">
				<signature="func reserveCapacityInt">
				<isStatic="False">
				<returnType="()">
				<Parameters>
				</Parameters>
			</Method>
			<Method>
				<name="resetBytes">
				<signature="func resetBytes(in: Swift.Range(Int))">
				<isStatic="False">
				<returnType="()">
				<Parameters>
					<Parameter="in: Swift.Range(Int">
				</Parameters>
			</Method>
			<Method>
				<name="withUnsafeBytes">
				<signature="func withUnsafeBytesSwift.UnsafeRawBufferPointer -> Self -> Self">
				<isStatic="False">
				<returnType="(0,0)">
				<Parameters>
				</Parameters>
			</Method>
			<Method>
				<name="withUnsafeMutableBytes">
				<signature="func withUnsafeMutableBytesSwift.UnsafeMutableRawBufferPointer -> Self -> Self">
				<isStatic="False">
				<returnType="(0,0)">
				<Parameters>
				</Parameters>
			</Method>
		</Struct>
		<Struct name="Foundation.Date">
			<Property>
				<name="customMirror">
				<signature="var customMirror: Swift.Mirror">
				<Static="False">
			</Property>
			<Property>
				<name="debugDescription">
				<signature="var debugDescription: Swift.String">
				<Static="False">
			</Property>
			<Property>
				<name="description">
				<signature="var description: Swift.String">
				<Static="False">
			</Property>
			<Property>
				<name="distantFuture">
				<signature="static var distantFuture: Foundation.Date">
				<Static="False">
			</Property>
			<Property>
				<name="distantPast">
				<signature="static var distantPast: Foundation.Date">
				<Static="False">
			</Property>
			<Property>
				<name="hashValue">
				<signature="var hashValue: Int">
				<Static="False">
			</Property>
			<Property>
				<name="timeIntervalBetween1970AndReferenceDate">
				<signature="static var timeIntervalBetween1970AndReferenceDate: Double">
				<Static="False">
			</Property>
			<Property>
				<name="timeIntervalSince1970">
				<signature="var timeIntervalSince1970: Double">
				<Static="False">
			</Property>
			<Property>
				<name="timeIntervalSinceNow">
				<signature="var timeIntervalSinceNow: Double">
				<Static="False">
			</Property>
			<Property>
				<name="timeIntervalSinceReferenceDate">
				<signature="var timeIntervalSinceReferenceDate: Double">
				<Static="False">
			</Property>
			<Property>
				<name="timeIntervalSinceReferenceDate">
				<signature="static var timeIntervalSinceReferenceDate: Double">
				<Static="False">
			</Property>
			<Method>
				<name="+">
				<signature="static func +(Foundation.Date, Double) -> Foundation.Date">
				<isStatic="True">
				<returnType="Foundation.Date">
				<Parameters>
					<Parameter="Foundation.Date">
					<Parameter="Double">
				</Parameters>
			</Method>
			<Method>
				<name="+=">
				<signature="static func +=(Foundation.Date, Double)">
				<isStatic="True">
				<returnType="()">
				<Parameters>
					<Parameter="Foundation.Date">
					<Parameter="Double">
				</Parameters>
			</Method>
			<Method>
				<name="-">
				<signature="static func -(Foundation.Date, Double) -> Foundation.Date">
				<isStatic="True">
				<returnType="Foundation.Date">
				<Parameters>
					<Parameter="Foundation.Date">
					<Parameter="Double">
				</Parameters>
			</Method>
			<Method>
				<name="-=">
				<signature="static func -=(Foundation.Date, Double)">
				<isStatic="True">
				<returnType="()">
				<Parameters>
					<Parameter="Foundation.Date">
					<Parameter="Double">
				</Parameters>
			</Method>
			<Method>
				<name="<">
				<signature="static func ((Foundation.Date, Foundation.Date) -) Bool">
				<isStatic="True">
				<returnType="Bool">
				<Parameters>
					<Parameter="(Foundation.Date">
					<Parameter="Foundation.Date">
				</Parameters>
			</Method>
			<Method>
				<name="==">
				<signature="static func ==(Foundation.Date, Foundation.Date) -> Bool">
				<isStatic="True">
				<returnType="Bool">
				<Parameters>
					<Parameter="Foundation.Date">
					<Parameter="Foundation.Date">
				</Parameters>
			</Method>
			<Method>
				<name=">">
				<signature="static func >(Foundation.Date, Foundation.Date) -> Bool">
				<isStatic="True">
				<returnType="Bool">
				<Parameters>
					<Parameter="Foundation.Date">
					<Parameter="Foundation.Date">
				</Parameters>
			</Method>
			<Method>
				<name="addTimeInterval">
				<signature="func addTimeIntervalDouble">
				<isStatic="False">
				<returnType="()">
				<Parameters>
				</Parameters>
			</Method>
			<Method>
				<name="addingTimeInterval">
				<signature="func addingTimeIntervalDouble -> Foundation.Date">
				<isStatic="False">
				<returnType="Foundation.Date">
				<Parameters>
				</Parameters>
			</Method>
			<Method>
				<name="advanced">
				<signature="func advanced(by: Double) -> Foundation.Date">
				<isStatic="False">
				<returnType="Foundation.Date">
				<Parameters>
					<Parameter="by: Double">
				</Parameters>
			</Method>
			<Method>
				<name="compare">
				<signature="func compareFoundation.Date -> Foundation.NSComparisonResult">
				<isStatic="False">
				<returnType="Foundation.NSComparisonResult">
				<Parameters>
				</Parameters>
			</Method>
			<Method>
				<name="description">
				<signature="func description(with: Foundation.Locale>) -? Swift.String">
				<isStatic="False">
				<returnType="Swift.String">
				<Parameters>
					<Parameter="with: Foundation.Locale>">
				</Parameters>
			</Method>
			<Method>
				<name="distance">
				<signature="func distance(to: Foundation.Date) -> Double">
				<isStatic="False">
				<returnType="Double">
				<Parameters>
					<Parameter="to: Foundation.Date">
				</Parameters>
			</Method>
			<Method>
				<name="encode">
				<signature="func encode(to: Swift.Encoder)">
				<isStatic="False">
				<returnType="()">
				<Parameters>
					<Parameter="to: Swift.Encoder">
				</Parameters>
			</Method>
			<Method>
				<name="hash">
				<signature="func hash(into: Swift.Hasher)">
				<isStatic="False">
				<returnType="()">
				<Parameters>
					<Parameter="into: Swift.Hasher">
				</Parameters>
			</Method>
			<Method>
				<name="timeIntervalSince">
				<signature="func timeIntervalSinceFoundation.Date -> Double">
				<isStatic="False">
				<returnType="Double">
				<Parameters>
				</Parameters>
			</Method>
		</Struct>
		<Struct name="Foundation.DateComponents">
			<Property>
				<name="calendar">
				<signature="var calendar: Foundation.Calendar?">
				<Static="False">
			</Property>
			<Property>
				<name="customMirror">
				<signature="var customMirror: Swift.Mirror">
				<Static="False">
			</Property>
			<Property>
				<name="date">
				<signature="var date: Foundation.Date?">
				<Static="False">
			</Property>
			<Property>
				<name="day">
				<signature="var day: Int?">
				<Static="False">
			</Property>
			<Property>
				<name="debugDescription">
				<signature="var debugDescription: Swift.String">
				<Static="False">
			</Property>
			<Property>
				<name="description">
				<signature="var description: Swift.String">
				<Static="False">
			</Property>
			<Property>
				<name="era">
				<signature="var era: Int?">
				<Static="False">
			</Property>
			<Property>
				<name="hashValue">
				<signature="var hashValue: Int">
				<Static="False">
			</Property>
			<Property>
				<name="hour">
				<signature="var hour: Int?">
				<Static="False">
			</Property>
			<Property>
				<name="isLeapMonth">
				<signature="var isLeapMonth: Bool?">
				<Static="False">
			</Property>
			<Property>
				<name="isValidDate">
				<signature="var isValidDate: Bool">
				<Static="False">
			</Property>
			<Property>
				<name="minute">
				<signature="var minute: Int?">
				<Static="False">
			</Property>
			<Property>
				<name="month">
				<signature="var month: Int?">
				<Static="False">
			</Property>
			<Property>
				<name="nanosecond">
				<signature="var nanosecond: Int?">
				<Static="False">
			</Property>
			<Property>
				<name="quarter">
				<signature="var quarter: Int?">
				<Static="False">
			</Property>
			<Property>
				<name="second">
				<signature="var second: Int?">
				<Static="False">
			</Property>
			<Property>
				<name="timeZone">
				<signature="var timeZone: Foundation.TimeZone?">
				<Static="False">
			</Property>
			<Property>
				<name="weekOfMonth">
				<signature="var weekOfMonth: Int?">
				<Static="False">
			</Property>
			<Property>
				<name="weekOfYear">
				<signature="var weekOfYear: Int?">
				<Static="False">
			</Property>
			<Property>
				<name="weekday">
				<signature="var weekday: Int?">
				<Static="False">
			</Property>
			<Property>
				<name="weekdayOrdinal">
				<signature="var weekdayOrdinal: Int?">
				<Static="False">
			</Property>
			<Property>
				<name="year">
				<signature="var year: Int?">
				<Static="False">
			</Property>
			<Property>
				<name="yearForWeekOfYear">
				<signature="var yearForWeekOfYear: Int?">
				<Static="False">
			</Property>
			<Method>
				<name="==">
				<signature="static func ==(Foundation.DateComponents, Foundation.DateComponents) -> Bool">
				<isStatic="True">
				<returnType="Bool">
				<Parameters>
					<Parameter="Foundation.DateComponents">
					<Parameter="Foundation.DateComponents">
				</Parameters>
			</Method>
			<Method>
				<name="encode">
				<signature="func encode(to: Swift.Encoder)">
				<isStatic="False">
				<returnType="()">
				<Parameters>
					<Parameter="to: Swift.Encoder">
				</Parameters>
			</Method>
			<Method>
				<name="hash">
				<signature="func hash(into: Swift.Hasher)">
				<isStatic="False">
				<returnType="()">
				<Parameters>
					<Parameter="into: Swift.Hasher">
				</Parameters>
			</Method>
			<Method>
				<name="isValidDate">
				<signature="func isValidDate(in: Foundation.Calendar) -> Bool">
				<isStatic="False">
				<returnType="Bool">
				<Parameters>
					<Parameter="in: Foundation.Calendar">
				</Parameters>
			</Method>
			<Method>
				<name="setValue">
				<signature="func setValue(: Int?, for: Foundation.Calendar.Component)">
				<isStatic="False">
				<returnType="()">
				<Parameters>
					<Parameter=": Int?">
					<Parameter="for: Foundation.Calendar.Component">
				</Parameters>
			</Method>
			<Method>
				<name="value">
				<signature="func value(for: Foundation.Calendar.Component) -> Int?">
				<isStatic="False">
				<returnType="Swift.Optional<Int>">
				<Parameters>
					<Parameter="for: Foundation.Calendar.Component">
				</Parameters>
			</Method>
		</Struct>
		<Struct name="Foundation.DateInterval">
			<Property>
				<name="customMirror">
				<signature="var customMirror: Swift.Mirror">
				<Static="False">
			</Property>
			<Property>
				<name="debugDescription">
				<signature="var debugDescription: Swift.String">
				<Static="False">
			</Property>
			<Property>
				<name="description">
				<signature="var description: Swift.String">
				<Static="False">
			</Property>
			<Property>
				<name="duration">
				<signature="var duration: Double">
				<Static="False">
			</Property>
			<Property>
				<name="end">
				<signature="var end: Foundation.Date">
				<Static="False">
			</Property>
			<Property>
				<name="hashValue">
				<signature="var hashValue: Int">
				<Static="False">
			</Property>
			<Property>
				<name="start">
				<signature="var start: Foundation.Date">
				<Static="False">
			</Property>
			<Method>
				<name="<">
				<signature="static func ((Foundation.DateInterval, Foundation.DateInterval) -) Bool">
				<isStatic="True">
				<returnType="Bool">
				<Parameters>
					<Parameter="(Foundation.DateInterval">
					<Parameter="Foundation.DateInterval">
				</Parameters>
			</Method>
			<Method>
				<name="==">
				<signature="static func ==(Foundation.DateInterval, Foundation.DateInterval) -> Bool">
				<isStatic="True">
				<returnType="Bool">
				<Parameters>
					<Parameter="Foundation.DateInterval">
					<Parameter="Foundation.DateInterval">
				</Parameters>
			</Method>
			<Method>
				<name="compare">
				<signature="func compareFoundation.DateInterval -> Foundation.NSComparisonResult">
				<isStatic="False">
				<returnType="Foundation.NSComparisonResult">
				<Parameters>
				</Parameters>
			</Method>
			<Method>
				<name="contains">
				<signature="func containsFoundation.Date -> Bool">
				<isStatic="False">
				<returnType="Bool">
				<Parameters>
				</Parameters>
			</Method>
			<Method>
				<name="encode">
				<signature="func encode(to: Swift.Encoder)">
				<isStatic="False">
				<returnType="()">
				<Parameters>
					<Parameter="to: Swift.Encoder">
				</Parameters>
			</Method>
			<Method>
				<name="hash">
				<signature="func hash(into: Swift.Hasher)">
				<isStatic="False">
				<returnType="()">
				<Parameters>
					<Parameter="into: Swift.Hasher">
				</Parameters>
			</Method>
			<Method>
				<name="intersection">
				<signature="func intersection(with: Foundation.DateInterval) -> Foundation.DateInterval?">
				<isStatic="False">
				<returnType="Swift.Optional<Foundation.DateInterval>">
				<Parameters>
					<Parameter="with: Foundation.DateInterval">
				</Parameters>
			</Method>
			<Method>
				<name="intersects">
				<signature="func intersectsFoundation.DateInterval -> Bool">
				<isStatic="False">
				<returnType="Bool">
				<Parameters>
				</Parameters>
			</Method>
		</Struct>
		<Struct name="Foundation.ErrorUserInfoKey">
			<Property>
				<name="NSURLErrorKey">
				<signature="static var NSURLErrorKey: Foundation.ErrorUserInfoKey">
				<Static="False">
			</Property>
			<Property>
				<name="filePathErrorKey">
				<signature="static var filePathErrorKey: Foundation.ErrorUserInfoKey">
				<Static="False">
			</Property>
			<Property>
				<name="helpAnchorErrorKey">
				<signature="static var helpAnchorErrorKey: Foundation.ErrorUserInfoKey">
				<Static="False">
			</Property>
			<Property>
				<name="localizedDescriptionKey">
				<signature="static var localizedDescriptionKey: Foundation.ErrorUserInfoKey">
				<Static="False">
			</Property>
			<Property>
				<name="localizedFailureReasonErrorKey">
				<signature="static var localizedFailureReasonErrorKey: Foundation.ErrorUserInfoKey">
				<Static="False">
			</Property>
			<Property>
				<name="localizedRecoveryOptionsErrorKey">
				<signature="static var localizedRecoveryOptionsErrorKey: Foundation.ErrorUserInfoKey">
				<Static="False">
			</Property>
			<Property>
				<name="localizedRecoverySuggestionErrorKey">
				<signature="static var localizedRecoverySuggestionErrorKey: Foundation.ErrorUserInfoKey">
				<Static="False">
			</Property>
			<Property>
				<name="rawValue">
				<signature="var rawValue: Swift.String">
				<Static="False">
			</Property>
			<Property>
				<name="recoveryAttempterErrorKey">
				<signature="static var recoveryAttempterErrorKey: Foundation.ErrorUserInfoKey">
				<Static="False">
			</Property>
			<Property>
				<name="stringEncodingErrorKey">
				<signature="static var stringEncodingErrorKey: Foundation.ErrorUserInfoKey">
				<Static="False">
			</Property>
			<Property>
				<name="underlyingErrorKey">
				<signature="static var underlyingErrorKey: Foundation.ErrorUserInfoKey">
				<Static="False">
			</Property>
		</Struct>
		<Struct name="Foundation.IndexPath">
			<Property>
				<name="count">
				<signature="var count: Int">
				<Static="False">
			</Property>
			<Property>
				<name="customMirror">
				<signature="var customMirror: Swift.Mirror">
				<Static="False">
			</Property>
			<Property>
				<name="debugDescription">
				<signature="var debugDescription: Swift.String">
				<Static="False">
			</Property>
			<Property>
				<name="description">
				<signature="var description: Swift.String">
				<Static="False">
			</Property>
			<Property>
				<name="endIndex">
				<signature="var endIndex: Int">
				<Static="False">
			</Property>
			<Property>
				<name="hashValue">
				<signature="var hashValue: Int">
				<Static="False">
			</Property>
			<Property>
				<name="startIndex">
				<signature="var startIndex: Int">
				<Static="False">
			</Property>
			<Method>
				<name="+">
				<signature="static func +(Foundation.IndexPath, Foundation.IndexPath) -> Foundation.IndexPath">
				<isStatic="True">
				<returnType="Foundation.IndexPath">
				<Parameters>
					<Parameter="Foundation.IndexPath">
					<Parameter="Foundation.IndexPath">
				</Parameters>
			</Method>
			<Method>
				<name="+=">
				<signature="static func +=(Foundation.IndexPath, Foundation.IndexPath)">
				<isStatic="True">
				<returnType="()">
				<Parameters>
					<Parameter="Foundation.IndexPath">
					<Parameter="Foundation.IndexPath">
				</Parameters>
			</Method>
			<Method>
				<name="<">
				<signature="static func ((Foundation.IndexPath, Foundation.IndexPath) -) Bool">
				<isStatic="True">
				<returnType="Bool">
				<Parameters>
					<Parameter="(Foundation.IndexPath">
					<Parameter="Foundation.IndexPath">
				</Parameters>
			</Method>
			<Method>
				<name="<=">
				<signature="static func (=(Foundation.IndexPath, Foundation.IndexPath) -) Bool">
				<isStatic="True">
				<returnType="Bool">
				<Parameters>
					<Parameter="=(Foundation.IndexPath">
					<Parameter="Foundation.IndexPath">
				</Parameters>
			</Method>
			<Method>
				<name="==">
				<signature="static func ==(Foundation.IndexPath, Foundation.IndexPath) -> Bool">
				<isStatic="True">
				<returnType="Bool">
				<Parameters>
					<Parameter="Foundation.IndexPath">
					<Parameter="Foundation.IndexPath">
				</Parameters>
			</Method>
			<Method>
				<name=">">
				<signature="static func >(Foundation.IndexPath, Foundation.IndexPath) -> Bool">
				<isStatic="True">
				<returnType="Bool">
				<Parameters>
					<Parameter="Foundation.IndexPath">
					<Parameter="Foundation.IndexPath">
				</Parameters>
			</Method>
			<Method>
				<name=">=">
				<signature="static func >=(Foundation.IndexPath, Foundation.IndexPath) -> Bool">
				<isStatic="True">
				<returnType="Bool">
				<Parameters>
					<Parameter="Foundation.IndexPath">
					<Parameter="Foundation.IndexPath">
				</Parameters>
			</Method>
			<Method>
				<name="append">
				<signature="func appendFoundation.IndexPath">
				<isStatic="False">
				<returnType="()">
				<Parameters>
				</Parameters>
			</Method>
			<Method>
				<name="appending">
				<signature="func appendingFoundation.IndexPath -> Foundation.IndexPath">
				<isStatic="False">
				<returnType="Foundation.IndexPath">
				<Parameters>
				</Parameters>
			</Method>
			<Method>
				<name="compare">
				<signature="func compareFoundation.IndexPath -> Foundation.NSComparisonResult">
				<isStatic="False">
				<returnType="Foundation.NSComparisonResult">
				<Parameters>
				</Parameters>
			</Method>
			<Method>
				<name="dropLast">
				<signature="func dropLast() -> Foundation.IndexPath">
				<isStatic="False">
				<returnType="Foundation.IndexPath">
				<Parameters>
					<Parameter="">
				</Parameters>
			</Method>
			<Method>
				<name="encode">
				<signature="func encode(to: Swift.Encoder)">
				<isStatic="False">
				<returnType="()">
				<Parameters>
					<Parameter="to: Swift.Encoder">
				</Parameters>
			</Method>
			<Method>
				<name="hash">
				<signature="func hash(into: Swift.Hasher)">
				<isStatic="False">
				<returnType="()">
				<Parameters>
					<Parameter="into: Swift.Hasher">
				</Parameters>
			</Method>
			<Method>
				<name="index">
				<signature="func index(after: Int) -> Int">
				<isStatic="False">
				<returnType="Int">
				<Parameters>
					<Parameter="after: Int">
				</Parameters>
			</Method>
			<Method>
				<name="makeIterator">
				<signature="func makeIterator() -> Swift.IndexingIterator(Foundation.IndexPath)">
				<isStatic="False">
				<returnType="Swift.IndexingIterator<Foundation.IndexPath>">
				<Parameters>
					<Parameter="">
				</Parameters>
			</Method>
		</Struct>
		<Struct name="Foundation.IndexSet">
			<Property>
				<name="count">
				<signature="var count: Int">
				<Static="False">
			</Property>
			<Property>
				<name="customMirror">
				<signature="var customMirror: Swift.Mirror">
				<Static="False">
			</Property>
			<Property>
				<name="debugDescription">
				<signature="var debugDescription: Swift.String">
				<Static="False">
			</Property>
			<Property>
				<name="description">
				<signature="var description: Swift.String">
				<Static="False">
			</Property>
			<Property>
				<name="endIndex">
				<signature="var endIndex: Foundation.IndexSet.Index">
				<Static="False">
			</Property>
			<Property>
				<name="first">
				<signature="var first: Int?">
				<Static="False">
			</Property>
			<Property>
				<name="hashValue">
				<signature="var hashValue: Int">
				<Static="False">
			</Property>
			<Property>
				<name="isEmpty">
				<signature="var isEmpty: Bool">
				<Static="False">
			</Property>
			<Property>
				<name="last">
				<signature="var last: Int?">
				<Static="False">
			</Property>
			<Property>
				<name="rangeView">
				<signature="var rangeView: Foundation.IndexSet.RangeView">
				<Static="False">
			</Property>
			<Property>
				<name="startIndex">
				<signature="var startIndex: Foundation.IndexSet.Index">
				<Static="False">
			</Property>
			<Method>
				<name="==">
				<signature="static func ==(Foundation.IndexSet, Foundation.IndexSet) -> Bool">
				<isStatic="True">
				<returnType="Bool">
				<Parameters>
					<Parameter="Foundation.IndexSet">
					<Parameter="Foundation.IndexSet">
				</Parameters>
			</Method>
			<Method>
				<name="contains">
				<signature="func contains(integersIn: Foundation.IndexSet) -> Bool">
				<isStatic="False">
				<returnType="Bool">
				<Parameters>
					<Parameter="integersIn: Foundation.IndexSet">
				</Parameters>
			</Method>
			<Method>
				<name="count">
				<signature="func count(in: Swift.Range(Int)) -> Int">
				<isStatic="False">
				<returnType="Int">
				<Parameters>
					<Parameter="in: Swift.Range(Int">
				</Parameters>
			</Method>
			<Method>
				<name="encode">
				<signature="func encode(to: Swift.Encoder)">
				<isStatic="False">
				<returnType="()">
				<Parameters>
					<Parameter="to: Swift.Encoder">
				</Parameters>
			</Method>
			<Method>
				<name="filteredIndexSet">
				<signature="func filteredIndexSet(includeInteger: Int -> Bool) -> Foundation.IndexSet">
				<isStatic="False">
				<returnType="Foundation.IndexSet">
				<Parameters>
					<Parameter="includeInteger: Int -> Bool">
				</Parameters>
			</Method>
			<Method>
				<name="formIndex">
				<signature="func formIndex(after: Foundation.IndexSet.Index)">
				<isStatic="False">
				<returnType="()">
				<Parameters>
					<Parameter="after: Foundation.IndexSet.Index">
				</Parameters>
			</Method>
			<Method>
				<name="formIntersection">
				<signature="func formIntersectionFoundation.IndexSet">
				<isStatic="False">
				<returnType="()">
				<Parameters>
				</Parameters>
			</Method>
			<Method>
				<name="formSymmetricDifference">
				<signature="func formSymmetricDifferenceFoundation.IndexSet">
				<isStatic="False">
				<returnType="()">
				<Parameters>
				</Parameters>
			</Method>
			<Method>
				<name="formUnion">
				<signature="func formUnionFoundation.IndexSet">
				<isStatic="False">
				<returnType="()">
				<Parameters>
				</Parameters>
			</Method>
			<Method>
				<name="hash">
				<signature="func hash(into: Swift.Hasher)">
				<isStatic="False">
				<returnType="()">
				<Parameters>
					<Parameter="into: Swift.Hasher">
				</Parameters>
			</Method>
			<Method>
				<name="index">
				<signature="func index(after: Foundation.IndexSet.Index) -> Foundation.IndexSet.Index">
				<isStatic="False">
				<returnType="Foundation.IndexSet.Index">
				<Parameters>
					<Parameter="after: Foundation.IndexSet.Index">
				</Parameters>
			</Method>
			<Method>
				<name="indexRange">
				<signature="func indexRange(in: Swift.Range(Int)) -> Swift.Range(Foundation.IndexSet.Index)">
				<isStatic="False">
				<returnType="Swift.Range<Foundation.IndexSet.Index>">
				<Parameters>
					<Parameter="in: Swift.Range(Int">
				</Parameters>
			</Method>
			<Method>
				<name="insert">
				<signature="func insert(integersIn: Swift.Range(Int))">
				<isStatic="False">
				<returnType="()">
				<Parameters>
					<Parameter="integersIn: Swift.Range(Int">
				</Parameters>
			</Method>
			<Method>
				<name="integerGreaterThan">
				<signature="func integerGreaterThanInt -> Int?">
				<isStatic="False">
				<returnType="Swift.Optional<Int>">
				<Parameters>
				</Parameters>
			</Method>
			<Method>
				<name="integerGreaterThanOrEqualTo">
				<signature="func integerGreaterThanOrEqualToInt -> Int?">
				<isStatic="False">
				<returnType="Swift.Optional<Int>">
				<Parameters>
				</Parameters>
			</Method>
			<Method>
				<name="integerLessThan">
				<signature="func integerLessThanInt -> Int?">
				<isStatic="False">
				<returnType="Swift.Optional<Int>">
				<Parameters>
				</Parameters>
			</Method>
			<Method>
				<name="integerLessThanOrEqualTo">
				<signature="func integerLessThanOrEqualToInt -> Int?">
				<isStatic="False">
				<returnType="Swift.Optional<Int>">
				<Parameters>
				</Parameters>
			</Method>
			<Method>
				<name="intersection">
				<signature="func intersectionFoundation.IndexSet -> Foundation.IndexSet">
				<isStatic="False">
				<returnType="Foundation.IndexSet">
				<Parameters>
				</Parameters>
			</Method>
			<Method>
				<name="intersects">
				<signature="func intersects(integersIn: Swift.Range(Int)) -> Bool">
				<isStatic="False">
				<returnType="Bool">
				<Parameters>
					<Parameter="integersIn: Swift.Range(Int">
				</Parameters>
			</Method>
			<Method>
				<name="makeIterator">
				<signature="func makeIterator() -> Swift.IndexingIterator(Foundation.IndexSet)">
				<isStatic="False">
				<returnType="Swift.IndexingIterator<Foundation.IndexSet>">
				<Parameters>
					<Parameter="">
				</Parameters>
			</Method>
			<Method>
				<name="rangeView">
				<signature="func rangeView(of: Swift.Range(Int)) -> Foundation.IndexSet.RangeView">
				<isStatic="False">
				<returnType="Foundation.IndexSet.RangeView">
				<Parameters>
					<Parameter="of: Swift.Range(Int">
				</Parameters>
			</Method>
			<Method>
				<name="remove">
				<signature="func remove(integersIn: Swift.ClosedRange(Int))">
				<isStatic="False">
				<returnType="()">
				<Parameters>
					<Parameter="integersIn: Swift.ClosedRange(Int">
				</Parameters>
			</Method>
			<Method>
				<name="removeAll">
				<signature="func removeAll()">
				<isStatic="False">
				<returnType="()">
				<Parameters>
					<Parameter="">
				</Parameters>
			</Method>
			<Method>
				<name="shift">
				<signature="func shift(startingAt: Int, by: Int)">
				<isStatic="False">
				<returnType="()">
				<Parameters>
					<Parameter="startingAt: Int">
					<Parameter="by: Int">
				</Parameters>
			</Method>
			<Method>
				<name="symmetricDifference">
				<signature="func symmetricDifferenceFoundation.IndexSet -> Foundation.IndexSet">
				<isStatic="False">
				<returnType="Foundation.IndexSet">
				<Parameters>
				</Parameters>
			</Method>
			<Method>
				<name="union">
				<signature="func unionFoundation.IndexSet -> Foundation.IndexSet">
				<isStatic="False">
				<returnType="Foundation.IndexSet">
				<Parameters>
				</Parameters>
			</Method>
			<Method>
				<name="update">
				<signature="func update(with: Int) -> Int?">
				<isStatic="False">
				<returnType="Swift.Optional<Int>">
				<Parameters>
					<Parameter="with: Int">
				</Parameters>
			</Method>
		</Struct>
		<Struct name="Foundation.IndexSet.Index">
			<Property>
				<name="description">
				<signature="var description: Swift.String">
				<Static="False">
			</Property>
			<Method>
				<name="<">
				<signature="static func ((Foundation.IndexSet.Index, Foundation.IndexSet.Index) -) Bool">
				<isStatic="True">
				<returnType="Bool">
				<Parameters>
					<Parameter="(Foundation.IndexSet.Index">
					<Parameter="Foundation.IndexSet.Index">
				</Parameters>
			</Method>
			<Method>
				<name="<=">
				<signature="static func (=(Foundation.IndexSet.Index, Foundation.IndexSet.Index) -) Bool">
				<isStatic="True">
				<returnType="Bool">
				<Parameters>
					<Parameter="=(Foundation.IndexSet.Index">
					<Parameter="Foundation.IndexSet.Index">
				</Parameters>
			</Method>
			<Method>
				<name="==">
				<signature="static func ==(Foundation.IndexSet.Index, Foundation.IndexSet.Index) -> Bool">
				<isStatic="True">
				<returnType="Bool">
				<Parameters>
					<Parameter="Foundation.IndexSet.Index">
					<Parameter="Foundation.IndexSet.Index">
				</Parameters>
			</Method>
			<Method>
				<name=">">
				<signature="static func >(Foundation.IndexSet.Index, Foundation.IndexSet.Index) -> Bool">
				<isStatic="True">
				<returnType="Bool">
				<Parameters>
					<Parameter="Foundation.IndexSet.Index">
					<Parameter="Foundation.IndexSet.Index">
				</Parameters>
			</Method>
			<Method>
				<name=">=">
				<signature="static func >=(Foundation.IndexSet.Index, Foundation.IndexSet.Index) -> Bool">
				<isStatic="True">
				<returnType="Bool">
				<Parameters>
					<Parameter="Foundation.IndexSet.Index">
					<Parameter="Foundation.IndexSet.Index">
				</Parameters>
			</Method>
		</Struct>
		<Struct name="Foundation.IndexSet.RangeView">
			<Property>
				<name="endIndex">
				<signature="var endIndex: Int">
				<Static="False">
			</Property>
			<Property>
				<name="startIndex">
				<signature="var startIndex: Int">
				<Static="False">
			</Property>
			<Method>
				<name="==">
				<signature="static func ==(Foundation.IndexSet.RangeView, Foundation.IndexSet.RangeView) -> Bool">
				<isStatic="True">
				<returnType="Bool">
				<Parameters>
					<Parameter="Foundation.IndexSet.RangeView">
					<Parameter="Foundation.IndexSet.RangeView">
				</Parameters>
			</Method>
			<Method>
				<name="index">
				<signature="func index(after: Int) -> Int">
				<isStatic="False">
				<returnType="Int">
				<Parameters>
					<Parameter="after: Int">
				</Parameters>
			</Method>
			<Method>
				<name="makeIterator">
				<signature="func makeIterator() -> Swift.IndexingIterator(Foundation.IndexSet.RangeView)">
				<isStatic="False">
				<returnType="Swift.IndexingIterator<Foundation.IndexSet.RangeView>">
				<Parameters>
					<Parameter="">
				</Parameters>
			</Method>
		</Struct>
		<Struct name="Foundation.JSONEncoder.OutputFormatting">
			<Property>
				<name="prettyPrinted">
				<signature="static var prettyPrinted: Foundation.JSONEncoder.OutputFormatting">
				<Static="False">
			</Property>
			<Property>
				<name="rawValue">
				<signature="var rawValue: UInt">
				<Static="False">
			</Property>
			<Property>
				<name="sortedKeys">
				<signature="static var sortedKeys: Foundation.JSONEncoder.OutputFormatting">
				<Static="False">
			</Property>
			<Property>
				<name="withoutEscapingSlashes">
				<signature="static var withoutEscapingSlashes: Foundation.JSONEncoder.OutputFormatting">
				<Static="False">
			</Property>
		</Struct>
		<Struct name="Foundation.Locale">
			<Property>
				<name="alternateQuotationBeginDelimiter">
				<signature="var alternateQuotationBeginDelimiter: String?">
				<Static="False">
			</Property>
			<Property>
				<name="alternateQuotationEndDelimiter">
				<signature="var alternateQuotationEndDelimiter: String?">
				<Static="False">
			</Property>
			<Property>
				<name="autoupdatingCurrent">
				<signature="static var autoupdatingCurrent: Foundation.Locale">
				<Static="False">
			</Property>
			<Property>
				<name="availableIdentifiers">
				<signature="static var availableIdentifiers: Swift.Array(Swift.String)">
				<Static="False">
			</Property>
			<Property>
				<name="availableLocaleIdentifiers">
				<signature="static var availableLocaleIdentifiers: Swift.Array(Swift.String)">
				<Static="False">
			</Property>
			<Property>
				<name="calendar">
				<signature="var calendar: Foundation.Calendar">
				<Static="False">
			</Property>
			<Property>
				<name="collationIdentifier">
				<signature="var collationIdentifier: String?">
				<Static="False">
			</Property>
			<Property>
				<name="collatorIdentifier">
				<signature="var collatorIdentifier: String?">
				<Static="False">
			</Property>
			<Property>
				<name="commonISOCurrencyCodes">
				<signature="static var commonISOCurrencyCodes: Swift.Array(Swift.String)">
				<Static="False">
			</Property>
			<Property>
				<name="countryCode">
				<signature="var countryCode: Swift.String">
				<Static="False">
			</Property>
			<Property>
				<name="currencyCode">
				<signature="var currencyCode: String?">
				<Static="False">
			</Property>
			<Property>
				<name="currencySymbol">
				<signature="var currencySymbol: String?">
				<Static="False">
			</Property>
			<Property>
				<name="current">
				<signature="static var current: Foundation.Locale">
				<Static="False">
			</Property>
			<Property>
				<name="customMirror">
				<signature="var customMirror: Swift.Mirror">
				<Static="False">
			</Property>
			<Property>
				<name="debugDescription">
				<signature="var debugDescription: Swift.String">
				<Static="False">
			</Property>
			<Property>
				<name="decimalSeparator">
				<signature="var decimalSeparator: String?">
				<Static="False">
			</Property>
			<Property>
				<name="description">
				<signature="var description: Swift.String">
				<Static="False">
			</Property>
			<Property>
				<name="exemplarCharacterSet">
				<signature="var exemplarCharacterSet: Foundation.CharacterSet?">
				<Static="False">
			</Property>
			<Property>
				<name="groupingSeparator">
				<signature="var groupingSeparator: String?">
				<Static="False">
			</Property>
			<Property>
				<name="hashValue">
				<signature="var hashValue: Int">
				<Static="False">
			</Property>
			<Property>
				<name="identifier">
				<signature="var identifier: Swift.String">
				<Static="False">
			</Property>
			<Property>
				<name="isoCountryCodes">
				<signature="static var isoCountryCodes: Swift.Array(Swift.String)">
				<Static="False">
			</Property>
			<Property>
				<name="isoCurrencyCodes">
				<signature="static var isoCurrencyCodes: Swift.Array(Swift.String)">
				<Static="False">
			</Property>
			<Property>
				<name="isoLanguageCodes">
				<signature="static var isoLanguageCodes: Swift.Array(Swift.String)">
				<Static="False">
			</Property>
			<Property>
				<name="isoRegionCodes">
				<signature="static var isoRegionCodes: Swift.Array(Swift.String)">
				<Static="False">
			</Property>
			<Property>
				<name="languageCode">
				<signature="var languageCode: String?">
				<Static="False">
			</Property>
			<Property>
				<name="localeIdentifier">
				<signature="var localeIdentifier: Swift.String">
				<Static="False">
			</Property>
			<Property>
				<name="preferredLanguages">
				<signature="static var preferredLanguages: Swift.Array(Swift.String)">
				<Static="False">
			</Property>
			<Property>
				<name="quotationBeginDelimiter">
				<signature="var quotationBeginDelimiter: String?">
				<Static="False">
			</Property>
			<Property>
				<name="quotationEndDelimiter">
				<signature="var quotationEndDelimiter: String?">
				<Static="False">
			</Property>
			<Property>
				<name="regionCode">
				<signature="var regionCode: String?">
				<Static="False">
			</Property>
			<Property>
				<name="scriptCode">
				<signature="var scriptCode: String?">
				<Static="False">
			</Property>
			<Property>
				<name="system">
				<signature="static var system: Foundation.Locale">
				<Static="False">
			</Property>
			<Property>
				<name="usesMetricSystem">
				<signature="var usesMetricSystem: Bool">
				<Static="False">
			</Property>
			<Property>
				<name="variantCode">
				<signature="var variantCode: String?">
				<Static="False">
			</Property>
			<Method>
				<name="==">
				<signature="static func ==(Foundation.Locale, Foundation.Locale) -> Bool">
				<isStatic="True">
				<returnType="Bool">
				<Parameters>
					<Parameter="Foundation.Locale">
					<Parameter="Foundation.Locale">
				</Parameters>
			</Method>
			<Method>
				<name="canonicalIdentifier">
				<signature="static func canonicalIdentifier(from: Swift.String) -> Swift.String">
				<isStatic="True">
				<returnType="Swift.String">
				<Parameters>
					<Parameter="from: Swift.String">
				</Parameters>
			</Method>
			<Method>
				<name="canonicalLanguageIdentifier">
				<signature="static func canonicalLanguageIdentifier(from: Swift.String) -> Swift.String">
				<isStatic="True">
				<returnType="Swift.String">
				<Parameters>
					<Parameter="from: Swift.String">
				</Parameters>
			</Method>
			<Method>
				<name="canonicalLocaleIdentifier">
				<signature="static func canonicalLocaleIdentifier(from: Swift.String) -> Swift.String">
				<isStatic="True">
				<returnType="Swift.String">
				<Parameters>
					<Parameter="from: Swift.String">
				</Parameters>
			</Method>
			<Method>
				<name="components">
				<signature="static func components(fromLocaleIdentifier: Swift.String) -> Swift.Dictionary(Swift.String, Swift.String)">
				<isStatic="True">
				<returnType="Swift.Dictionary<Swift.String, Swift.String>">
				<Parameters>
					<Parameter="fromLocaleIdentifier: Swift.String">
				</Parameters>
			</Method>
			<Method>
				<name="encode">
				<signature="func encode(to: Swift.Encoder)">
				<isStatic="False">
				<returnType="()">
				<Parameters>
					<Parameter="to: Swift.Encoder">
				</Parameters>
			</Method>
			<Method>
				<name="hash">
				<signature="func hash(into: Swift.Hasher)">
				<isStatic="False">
				<returnType="()">
				<Parameters>
					<Parameter="into: Swift.Hasher">
				</Parameters>
			</Method>
			<Method>
				<name="identifier">
				<signature="static func identifier(fromWindowsLocaleCode: Int) -> String?">
				<isStatic="True">
				<returnType="Swift.Optional<Swift.String>">
				<Parameters>
					<Parameter="fromWindowsLocaleCode: Int">
				</Parameters>
			</Method>
			<Method>
				<name="localeIdentifier">
				<signature="static func localeIdentifier(fromWindowsLocaleCode: Swift.UInt32) -> String?">
				<isStatic="True">
				<returnType="Swift.Optional<Swift.String>">
				<Parameters>
					<Parameter="fromWindowsLocaleCode: Swift.UInt32">
				</Parameters>
			</Method>
			<Method>
				<name="localizedString">
				<signature="func localizedString(forLocaleIdentifier: Swift.String) -> Swift.String">
				<isStatic="False">
				<returnType="Swift.String">
				<Parameters>
					<Parameter="forLocaleIdentifier: Swift.String">
				</Parameters>
			</Method>
			<Method>
				<name="windowsLocaleCode">
				<signature="static func windowsLocaleCode(fromLocaleIdentifier: Swift.String) -> Swift.UInt32">
				<isStatic="True">
				<returnType="Swift.UInt32">
				<Parameters>
					<Parameter="fromLocaleIdentifier: Swift.String">
				</Parameters>
			</Method>
		</Struct>
		<Struct name="Foundation.MachError">
			<Property>
				<name="aborted">
				<signature="static var aborted: Darwin.MachErrorCode">
				<Static="False">
			</Property>
			<Property>
				<name="alreadyInSet">
				<signature="static var alreadyInSet: Darwin.MachErrorCode">
				<Static="False">
			</Property>
			<Property>
				<name="alreadyWaiting">
				<signature="static var alreadyWaiting: Darwin.MachErrorCode">
				<Static="False">
			</Property>
			<Property>
				<name="codesignError">
				<signature="static var codesignError: Darwin.MachErrorCode">
				<Static="False">
			</Property>
			<Property>
				<name="defaultSet">
				<signature="static var defaultSet: Darwin.MachErrorCode">
				<Static="False">
			</Property>
			<Property>
				<name="errorDomain">
				<signature="static var errorDomain: Swift.String">
				<Static="False">
			</Property>
			<Property>
				<name="exceptionProtected">
				<signature="static var exceptionProtected: Darwin.MachErrorCode">
				<Static="False">
			</Property>
			<Property>
				<name="failure">
				<signature="static var failure: Darwin.MachErrorCode">
				<Static="False">
			</Property>
			<Property>
				<name="hashValue">
				<signature="var hashValue: Int">
				<Static="False">
			</Property>
			<Property>
				<name="invalidAddress">
				<signature="static var invalidAddress: Darwin.MachErrorCode">
				<Static="False">
			</Property>
			<Property>
				<name="invalidArgument">
				<signature="static var invalidArgument: Darwin.MachErrorCode">
				<Static="False">
			</Property>
			<Property>
				<name="invalidCapability">
				<signature="static var invalidCapability: Darwin.MachErrorCode">
				<Static="False">
			</Property>
			<Property>
				<name="invalidHost">
				<signature="static var invalidHost: Darwin.MachErrorCode">
				<Static="False">
			</Property>
			<Property>
				<name="invalidLedger">
				<signature="static var invalidLedger: Darwin.MachErrorCode">
				<Static="False">
			</Property>
			<Property>
				<name="invalidMemoryControl">
				<signature="static var invalidMemoryControl: Darwin.MachErrorCode">
				<Static="False">
			</Property>
			<Property>
				<name="invalidName">
				<signature="static var invalidName: Darwin.MachErrorCode">
				<Static="False">
			</Property>
			<Property>
				<name="invalidObject">
				<signature="static var invalidObject: Darwin.MachErrorCode">
				<Static="False">
			</Property>
			<Property>
				<name="invalidPolicy">
				<signature="static var invalidPolicy: Darwin.MachErrorCode">
				<Static="False">
			</Property>
			<Property>
				<name="invalidProcessorSet">
				<signature="static var invalidProcessorSet: Darwin.MachErrorCode">
				<Static="False">
			</Property>
			<Property>
				<name="invalidRight">
				<signature="static var invalidRight: Darwin.MachErrorCode">
				<Static="False">
			</Property>
			<Property>
				<name="invalidSecurity">
				<signature="static var invalidSecurity: Darwin.MachErrorCode">
				<Static="False">
			</Property>
			<Property>
				<name="invalidTask">
				<signature="static var invalidTask: Darwin.MachErrorCode">
				<Static="False">
			</Property>
			<Property>
				<name="invalidValue">
				<signature="static var invalidValue: Darwin.MachErrorCode">
				<Static="False">
			</Property>
			<Property>
				<name="lockOwned">
				<signature="static var lockOwned: Darwin.MachErrorCode">
				<Static="False">
			</Property>
			<Property>
				<name="lockOwnedSelf">
				<signature="static var lockOwnedSelf: Darwin.MachErrorCode">
				<Static="False">
			</Property>
			<Property>
				<name="lockSetDestroyed">
				<signature="static var lockSetDestroyed: Darwin.MachErrorCode">
				<Static="False">
			</Property>
			<Property>
				<name="lockUnstable">
				<signature="static var lockUnstable: Darwin.MachErrorCode">
				<Static="False">
			</Property>
			<Property>
				<name="memoryDataMoved">
				<signature="static var memoryDataMoved: Darwin.MachErrorCode">
				<Static="False">
			</Property>
			<Property>
				<name="memoryError">
				<signature="static var memoryError: Darwin.MachErrorCode">
				<Static="False">
			</Property>
			<Property>
				<name="memoryFailure">
				<signature="static var memoryFailure: Darwin.MachErrorCode">
				<Static="False">
			</Property>
			<Property>
				<name="memoryPresent">
				<signature="static var memoryPresent: Darwin.MachErrorCode">
				<Static="False">
			</Property>
			<Property>
				<name="memoryRestartCopy">
				<signature="static var memoryRestartCopy: Darwin.MachErrorCode">
				<Static="False">
			</Property>
			<Property>
				<name="nameExists">
				<signature="static var nameExists: Darwin.MachErrorCode">
				<Static="False">
			</Property>
			<Property>
				<name="noAccess">
				<signature="static var noAccess: Darwin.MachErrorCode">
				<Static="False">
			</Property>
			<Property>
				<name="noSpace">
				<signature="static var noSpace: Darwin.MachErrorCode">
				<Static="False">
			</Property>
			<Property>
				<name="nodeDown">
				<signature="static var nodeDown: Darwin.MachErrorCode">
				<Static="False">
			</Property>
			<Property>
				<name="notDepressed">
				<signature="static var notDepressed: Darwin.MachErrorCode">
				<Static="False">
			</Property>
			<Property>
				<name="notInSet">
				<signature="static var notInSet: Darwin.MachErrorCode">
				<Static="False">
			</Property>
			<Property>
				<name="notReceiver">
				<signature="static var notReceiver: Darwin.MachErrorCode">
				<Static="False">
			</Property>
			<Property>
				<name="notSupported">
				<signature="static var notSupported: Darwin.MachErrorCode">
				<Static="False">
			</Property>
			<Property>
				<name="notWaiting">
				<signature="static var notWaiting: Darwin.MachErrorCode">
				<Static="False">
			</Property>
			<Property>
				<name="operationTimedOut">
				<signature="static var operationTimedOut: Darwin.MachErrorCode">
				<Static="False">
			</Property>
			<Property>
				<name="policyLimit">
				<signature="static var policyLimit: Darwin.MachErrorCode">
				<Static="False">
			</Property>
			<Property>
				<name="policyStatic">
				<signature="static var policyStatic: Darwin.MachErrorCode">
				<Static="False">
			</Property>
			<Property>
				<name="protectionFailure">
				<signature="static var protectionFailure: Darwin.MachErrorCode">
				<Static="False">
			</Property>
			<Property>
				<name="resourceShortage">
				<signature="static var resourceShortage: Darwin.MachErrorCode">
				<Static="False">
			</Property>
			<Property>
				<name="rightExists">
				<signature="static var rightExists: Darwin.MachErrorCode">
				<Static="False">
			</Property>
			<Property>
				<name="rpcContinueOrphan">
				<signature="static var rpcContinueOrphan: Darwin.MachErrorCode">
				<Static="False">
			</Property>
			<Property>
				<name="rpcServerTerminated">
				<signature="static var rpcServerTerminated: Darwin.MachErrorCode">
				<Static="False">
			</Property>
			<Property>
				<name="rpcTerminateOrphan">
				<signature="static var rpcTerminateOrphan: Darwin.MachErrorCode">
				<Static="False">
			</Property>
			<Property>
				<name="semaphoreDestroyed">
				<signature="static var semaphoreDestroyed: Darwin.MachErrorCode">
				<Static="False">
			</Property>
			<Property>
				<name="success">
				<signature="static var success: Darwin.MachErrorCode">
				<Static="False">
			</Property>
			<Property>
				<name="terminated">
				<signature="static var terminated: Darwin.MachErrorCode">
				<Static="False">
			</Property>
			<Property>
				<name="userReferencesOverflow">
				<signature="static var userReferencesOverflow: Darwin.MachErrorCode">
				<Static="False">
			</Property>
		</Struct>
		<Struct name="Foundation.Measurement">
			<Property>
				<name="customMirror">
				<signature="var customMirror: Swift.Mirror">
				<Static="False">
			</Property>
			<Property>
				<name="debugDescription">
				<signature="var debugDescription: Swift.String">
				<Static="False">
			</Property>
			<Property>
				<name="description">
				<signature="var description: Swift.String">
				<Static="False">
			</Property>
			<Property>
				<name="hashValue">
				<signature="var hashValue: Int">
				<Static="False">
			</Property>
			<Property>
				<name="unit">
				<signature="var unit: Self">
				<Static="False">
			</Property>
			<Property>
				<name="value">
				<signature="var value: Double">
				<Static="False">
			</Property>
			<Method>
				<name="*">
				<signature="static func *(Foundation.Measurement(Self), Double) -> Foundation.Measurement(Self)">
				<isStatic="True">
				<returnType="Foundation.Measurement<(0,0)>">
				<Parameters>
					<Parameter="Foundation.Measurement(Self">
				</Parameters>
			</Method>
			<Method>
				<name="+">
				<signature="static func +(Foundation.Measurement(Self), Foundation.Measurement(Self)) -> Foundation.Measurement(Self)">
				<isStatic="True">
				<returnType="Foundation.Measurement<(0,0)>">
				<Parameters>
					<Parameter="Foundation.Measurement(Self">
				</Parameters>
			</Method>
			<Method>
				<name="-">
				<signature="static func -(Foundation.Measurement(Self), Foundation.Measurement(Self)) -> Foundation.Measurement(Self)">
				<isStatic="True">
				<returnType="Foundation.Measurement<(0,0)>">
				<Parameters>
					<Parameter="Foundation.Measurement(Self">
				</Parameters>
			</Method>
			<Method>
				<name="/">
				<signature="static func /(Foundation.Measurement(Self), Double) -> Foundation.Measurement(Self)">
				<isStatic="True">
				<returnType="Foundation.Measurement<(0,0)>">
				<Parameters>
					<Parameter="Foundation.Measurement(Self">
				</Parameters>
			</Method>
			<Method>
				<name="<">
				<signature="static func ((Foundation.Measurement(???), Foundation.Measurement(???)) -) Bool">
				<isStatic="True">
				<returnType="Bool">
				<Parameters>
					<Parameter="(Foundation.Measurement(???">
				</Parameters>
			</Method>
			<Method>
				<name="==">
				<signature="static func ==(Foundation.Measurement(???), Foundation.Measurement(???)) -> Bool">
				<isStatic="True">
				<returnType="Bool">
				<Parameters>
					<Parameter="Foundation.Measurement(???">
				</Parameters>
			</Method>
			<Method>
				<name="encode">
				<signature="func encode(to: Swift.Encoder)">
				<isStatic="False">
				<returnType="()">
				<Parameters>
					<Parameter="to: Swift.Encoder">
				</Parameters>
			</Method>
			<Method>
				<name="hash">
				<signature="func hash(into: Swift.Hasher)">
				<isStatic="False">
				<returnType="()">
				<Parameters>
					<Parameter="into: Swift.Hasher">
				</Parameters>
			</Method>
		</Struct>
		<Struct name="Foundation.NSDecimal">
		</Struct>
		<Struct name="Foundation.NSFastEnumerationIterator">
			<Method>
				<name="next">
				<signature="func next() -> Any?">
				<isStatic="False">
				<returnType="Swift.Optional<Swift.Any>">
				<Parameters>
					<Parameter="">
				</Parameters>
			</Method>
		</Struct>
		<Struct name="Foundation.NSIndexSetIterator">
			<Method>
				<name="next">
				<signature="func next() -> Int?">
				<isStatic="False">
				<returnType="Swift.Optional<Int>">
				<Parameters>
					<Parameter="">
				</Parameters>
			</Method>
		</Struct>
		<Struct name="Foundation.NSKeyValueObservedChange">
			<Property>
				<name="indexes">
				<signature="var indexes: Foundation.IndexSet?">
				<Static="False">
			</Property>
			<Property>
				<name="isPrior">
				<signature="var isPrior: Bool">
				<Static="False">
			</Property>
			<Property>
				<name="kind">
				<signature="var kind: Foundation.NSKeyValueChange">
				<Static="False">
			</Property>
			<Property>
				<name="newValue">
				<signature="var newValue: Self?">
				<Static="False">
			</Property>
			<Property>
				<name="oldValue">
				<signature="var oldValue: Self?">
				<Static="False">
			</Property>
		</Struct>
		<Struct name="Foundation.Notification">
			<Property>
				<name="customMirror">
				<signature="var customMirror: Swift.Mirror">
				<Static="False">
			</Property>
			<Property>
				<name="debugDescription">
				<signature="var debugDescription: Swift.String">
				<Static="False">
			</Property>
			<Property>
				<name="description">
				<signature="var description: Swift.String">
				<Static="False">
			</Property>
			<Property>
				<name="hashValue">
				<signature="var hashValue: Int">
				<Static="False">
			</Property>
			<Property>
				<name="object">
				<signature="var object: Any?">
				<Static="False">
			</Property>
			<Property>
				<name="userInfo">
				<signature="var userInfo: Dictionary(Swift.AnyHashable, Swift.Any)?">
				<Static="False">
			</Property>
			<Method>
				<name="==">
				<signature="static func ==(Foundation.Notification, Foundation.Notification) -> Bool">
				<isStatic="True">
				<returnType="Bool">
				<Parameters>
					<Parameter="Foundation.Notification">
					<Parameter="Foundation.Notification">
				</Parameters>
			</Method>
			<Method>
				<name="hash">
				<signature="func hash(into: Swift.Hasher)">
				<isStatic="False">
				<returnType="()">
				<Parameters>
					<Parameter="into: Swift.Hasher">
				</Parameters>
			</Method>
		</Struct>
		<Struct name="Foundation.POSIXError">
			<Property>
				<name="E2BIG">
				<signature="static var E2BIG: Darwin.POSIXErrorCode">
				<Static="False">
			</Property>
			<Property>
				<name="EACCES">
				<signature="static var EACCES: Darwin.POSIXErrorCode">
				<Static="False">
			</Property>
			<Property>
				<name="EADDRINUSE">
				<signature="static var EADDRINUSE: Darwin.POSIXErrorCode">
				<Static="False">
			</Property>
			<Property>
				<name="EADDRNOTAVAIL">
				<signature="static var EADDRNOTAVAIL: Darwin.POSIXErrorCode">
				<Static="False">
			</Property>
			<Property>
				<name="EAFNOSUPPORT">
				<signature="static var EAFNOSUPPORT: Darwin.POSIXErrorCode">
				<Static="False">
			</Property>
			<Property>
				<name="EAGAIN">
				<signature="static var EAGAIN: Darwin.POSIXErrorCode">
				<Static="False">
			</Property>
			<Property>
				<name="EALREADY">
				<signature="static var EALREADY: Darwin.POSIXErrorCode">
				<Static="False">
			</Property>
			<Property>
				<name="EAUTH">
				<signature="static var EAUTH: Darwin.POSIXErrorCode">
				<Static="False">
			</Property>
			<Property>
				<name="EBADARCH">
				<signature="static var EBADARCH: Darwin.POSIXErrorCode">
				<Static="False">
			</Property>
			<Property>
				<name="EBADEXEC">
				<signature="static var EBADEXEC: Darwin.POSIXErrorCode">
				<Static="False">
			</Property>
			<Property>
				<name="EBADF">
				<signature="static var EBADF: Darwin.POSIXErrorCode">
				<Static="False">
			</Property>
			<Property>
				<name="EBADMACHO">
				<signature="static var EBADMACHO: Darwin.POSIXErrorCode">
				<Static="False">
			</Property>
			<Property>
				<name="EBADMSG">
				<signature="static var EBADMSG: Darwin.POSIXErrorCode">
				<Static="False">
			</Property>
			<Property>
				<name="EBADRPC">
				<signature="static var EBADRPC: Darwin.POSIXErrorCode">
				<Static="False">
			</Property>
			<Property>
				<name="EBUSY">
				<signature="static var EBUSY: Darwin.POSIXErrorCode">
				<Static="False">
			</Property>
			<Property>
				<name="ECANCELED">
				<signature="static var ECANCELED: Darwin.POSIXErrorCode">
				<Static="False">
			</Property>
			<Property>
				<name="ECHILD">
				<signature="static var ECHILD: Darwin.POSIXErrorCode">
				<Static="False">
			</Property>
			<Property>
				<name="ECONNABORTED">
				<signature="static var ECONNABORTED: Darwin.POSIXErrorCode">
				<Static="False">
			</Property>
			<Property>
				<name="ECONNREFUSED">
				<signature="static var ECONNREFUSED: Darwin.POSIXErrorCode">
				<Static="False">
			</Property>
			<Property>
				<name="ECONNRESET">
				<signature="static var ECONNRESET: Darwin.POSIXErrorCode">
				<Static="False">
			</Property>
			<Property>
				<name="EDEADLK">
				<signature="static var EDEADLK: Darwin.POSIXErrorCode">
				<Static="False">
			</Property>
			<Property>
				<name="EDESTADDRREQ">
				<signature="static var EDESTADDRREQ: Darwin.POSIXErrorCode">
				<Static="False">
			</Property>
			<Property>
				<name="EDEVERR">
				<signature="static var EDEVERR: Darwin.POSIXErrorCode">
				<Static="False">
			</Property>
			<Property>
				<name="EDOM">
				<signature="static var EDOM: Darwin.POSIXErrorCode">
				<Static="False">
			</Property>
			<Property>
				<name="EDQUOT">
				<signature="static var EDQUOT: Darwin.POSIXErrorCode">
				<Static="False">
			</Property>
			<Property>
				<name="EEXIST">
				<signature="static var EEXIST: Darwin.POSIXErrorCode">
				<Static="False">
			</Property>
			<Property>
				<name="EFAULT">
				<signature="static var EFAULT: Darwin.POSIXErrorCode">
				<Static="False">
			</Property>
			<Property>
				<name="EFBIG">
				<signature="static var EFBIG: Darwin.POSIXErrorCode">
				<Static="False">
			</Property>
			<Property>
				<name="EFTYPE">
				<signature="static var EFTYPE: Darwin.POSIXErrorCode">
				<Static="False">
			</Property>
			<Property>
				<name="EHOSTDOWN">
				<signature="static var EHOSTDOWN: Darwin.POSIXErrorCode">
				<Static="False">
			</Property>
			<Property>
				<name="EHOSTUNREACH">
				<signature="static var EHOSTUNREACH: Darwin.POSIXErrorCode">
				<Static="False">
			</Property>
			<Property>
				<name="EIDRM">
				<signature="static var EIDRM: Darwin.POSIXErrorCode">
				<Static="False">
			</Property>
			<Property>
				<name="EILSEQ">
				<signature="static var EILSEQ: Darwin.POSIXErrorCode">
				<Static="False">
			</Property>
			<Property>
				<name="EINPROGRESS">
				<signature="static var EINPROGRESS: Darwin.POSIXErrorCode">
				<Static="False">
			</Property>
			<Property>
				<name="EINTR">
				<signature="static var EINTR: Darwin.POSIXErrorCode">
				<Static="False">
			</Property>
			<Property>
				<name="EINVAL">
				<signature="static var EINVAL: Darwin.POSIXErrorCode">
				<Static="False">
			</Property>
			<Property>
				<name="EIO">
				<signature="static var EIO: Darwin.POSIXErrorCode">
				<Static="False">
			</Property>
			<Property>
				<name="EISCONN">
				<signature="static var EISCONN: Darwin.POSIXErrorCode">
				<Static="False">
			</Property>
			<Property>
				<name="EISDIR">
				<signature="static var EISDIR: Darwin.POSIXErrorCode">
				<Static="False">
			</Property>
			<Property>
				<name="ELOOP">
				<signature="static var ELOOP: Darwin.POSIXErrorCode">
				<Static="False">
			</Property>
			<Property>
				<name="EMFILE">
				<signature="static var EMFILE: Darwin.POSIXErrorCode">
				<Static="False">
			</Property>
			<Property>
				<name="EMLINK">
				<signature="static var EMLINK: Darwin.POSIXErrorCode">
				<Static="False">
			</Property>
			<Property>
				<name="EMSGSIZE">
				<signature="static var EMSGSIZE: Darwin.POSIXErrorCode">
				<Static="False">
			</Property>
			<Property>
				<name="EMULTIHOP">
				<signature="static var EMULTIHOP: Darwin.POSIXErrorCode">
				<Static="False">
			</Property>
			<Property>
				<name="ENAMETOOLONG">
				<signature="static var ENAMETOOLONG: Darwin.POSIXErrorCode">
				<Static="False">
			</Property>
			<Property>
				<name="ENEEDAUTH">
				<signature="static var ENEEDAUTH: Darwin.POSIXErrorCode">
				<Static="False">
			</Property>
			<Property>
				<name="ENETDOWN">
				<signature="static var ENETDOWN: Darwin.POSIXErrorCode">
				<Static="False">
			</Property>
			<Property>
				<name="ENETRESET">
				<signature="static var ENETRESET: Darwin.POSIXErrorCode">
				<Static="False">
			</Property>
			<Property>
				<name="ENETUNREACH">
				<signature="static var ENETUNREACH: Darwin.POSIXErrorCode">
				<Static="False">
			</Property>
			<Property>
				<name="ENFILE">
				<signature="static var ENFILE: Darwin.POSIXErrorCode">
				<Static="False">
			</Property>
			<Property>
				<name="ENOATTR">
				<signature="static var ENOATTR: Darwin.POSIXErrorCode">
				<Static="False">
			</Property>
			<Property>
				<name="ENOBUFS">
				<signature="static var ENOBUFS: Darwin.POSIXErrorCode">
				<Static="False">
			</Property>
			<Property>
				<name="ENODATA">
				<signature="static var ENODATA: Darwin.POSIXErrorCode">
				<Static="False">
			</Property>
			<Property>
				<name="ENODEV">
				<signature="static var ENODEV: Darwin.POSIXErrorCode">
				<Static="False">
			</Property>
			<Property>
				<name="ENOENT">
				<signature="static var ENOENT: Darwin.POSIXErrorCode">
				<Static="False">
			</Property>
			<Property>
				<name="ENOEXEC">
				<signature="static var ENOEXEC: Darwin.POSIXErrorCode">
				<Static="False">
			</Property>
			<Property>
				<name="ENOLCK">
				<signature="static var ENOLCK: Darwin.POSIXErrorCode">
				<Static="False">
			</Property>
			<Property>
				<name="ENOLINK">
				<signature="static var ENOLINK: Darwin.POSIXErrorCode">
				<Static="False">
			</Property>
			<Property>
				<name="ENOMEM">
				<signature="static var ENOMEM: Darwin.POSIXErrorCode">
				<Static="False">
			</Property>
			<Property>
				<name="ENOMSG">
				<signature="static var ENOMSG: Darwin.POSIXErrorCode">
				<Static="False">
			</Property>
			<Property>
				<name="ENOPOLICY">
				<signature="static var ENOPOLICY: Darwin.POSIXErrorCode">
				<Static="False">
			</Property>
			<Property>
				<name="ENOPROTOOPT">
				<signature="static var ENOPROTOOPT: Darwin.POSIXErrorCode">
				<Static="False">
			</Property>
			<Property>
				<name="ENOSPC">
				<signature="static var ENOSPC: Darwin.POSIXErrorCode">
				<Static="False">
			</Property>
			<Property>
				<name="ENOSR">
				<signature="static var ENOSR: Darwin.POSIXErrorCode">
				<Static="False">
			</Property>
			<Property>
				<name="ENOSTR">
				<signature="static var ENOSTR: Darwin.POSIXErrorCode">
				<Static="False">
			</Property>
			<Property>
				<name="ENOSYS">
				<signature="static var ENOSYS: Darwin.POSIXErrorCode">
				<Static="False">
			</Property>
			<Property>
				<name="ENOTBLK">
				<signature="static var ENOTBLK: Darwin.POSIXErrorCode">
				<Static="False">
			</Property>
			<Property>
				<name="ENOTCONN">
				<signature="static var ENOTCONN: Darwin.POSIXErrorCode">
				<Static="False">
			</Property>
			<Property>
				<name="ENOTDIR">
				<signature="static var ENOTDIR: Darwin.POSIXErrorCode">
				<Static="False">
			</Property>
			<Property>
				<name="ENOTEMPTY">
				<signature="static var ENOTEMPTY: Darwin.POSIXErrorCode">
				<Static="False">
			</Property>
			<Property>
				<name="ENOTRECOVERABLE">
				<signature="static var ENOTRECOVERABLE: Darwin.POSIXErrorCode">
				<Static="False">
			</Property>
			<Property>
				<name="ENOTSOCK">
				<signature="static var ENOTSOCK: Darwin.POSIXErrorCode">
				<Static="False">
			</Property>
			<Property>
				<name="ENOTSUP">
				<signature="static var ENOTSUP: Darwin.POSIXErrorCode">
				<Static="False">
			</Property>
			<Property>
				<name="ENOTTY">
				<signature="static var ENOTTY: Darwin.POSIXErrorCode">
				<Static="False">
			</Property>
			<Property>
				<name="ENXIO">
				<signature="static var ENXIO: Darwin.POSIXErrorCode">
				<Static="False">
			</Property>
			<Property>
				<name="EOVERFLOW">
				<signature="static var EOVERFLOW: Darwin.POSIXErrorCode">
				<Static="False">
			</Property>
			<Property>
				<name="EOWNERDEAD">
				<signature="static var EOWNERDEAD: Darwin.POSIXErrorCode">
				<Static="False">
			</Property>
			<Property>
				<name="EPERM">
				<signature="static var EPERM: Darwin.POSIXErrorCode">
				<Static="False">
			</Property>
			<Property>
				<name="EPFNOSUPPORT">
				<signature="static var EPFNOSUPPORT: Darwin.POSIXErrorCode">
				<Static="False">
			</Property>
			<Property>
				<name="EPIPE">
				<signature="static var EPIPE: Darwin.POSIXErrorCode">
				<Static="False">
			</Property>
			<Property>
				<name="EPROCLIM">
				<signature="static var EPROCLIM: Darwin.POSIXErrorCode">
				<Static="False">
			</Property>
			<Property>
				<name="EPROCUNAVAIL">
				<signature="static var EPROCUNAVAIL: Darwin.POSIXErrorCode">
				<Static="False">
			</Property>
			<Property>
				<name="EPROGMISMATCH">
				<signature="static var EPROGMISMATCH: Darwin.POSIXErrorCode">
				<Static="False">
			</Property>
			<Property>
				<name="EPROGUNAVAIL">
				<signature="static var EPROGUNAVAIL: Darwin.POSIXErrorCode">
				<Static="False">
			</Property>
			<Property>
				<name="EPROTO">
				<signature="static var EPROTO: Darwin.POSIXErrorCode">
				<Static="False">
			</Property>
			<Property>
				<name="EPROTONOSUPPORT">
				<signature="static var EPROTONOSUPPORT: Darwin.POSIXErrorCode">
				<Static="False">
			</Property>
			<Property>
				<name="EPROTOTYPE">
				<signature="static var EPROTOTYPE: Darwin.POSIXErrorCode">
				<Static="False">
			</Property>
			<Property>
				<name="EPWROFF">
				<signature="static var EPWROFF: Darwin.POSIXErrorCode">
				<Static="False">
			</Property>
			<Property>
				<name="EQFULL">
				<signature="static var EQFULL: Darwin.POSIXErrorCode">
				<Static="False">
			</Property>
			<Property>
				<name="ERANGE">
				<signature="static var ERANGE: Darwin.POSIXErrorCode">
				<Static="False">
			</Property>
			<Property>
				<name="EREMOTE">
				<signature="static var EREMOTE: Darwin.POSIXErrorCode">
				<Static="False">
			</Property>
			<Property>
				<name="EROFS">
				<signature="static var EROFS: Darwin.POSIXErrorCode">
				<Static="False">
			</Property>
			<Property>
				<name="ERPCMISMATCH">
				<signature="static var ERPCMISMATCH: Darwin.POSIXErrorCode">
				<Static="False">
			</Property>
			<Property>
				<name="ESHLIBVERS">
				<signature="static var ESHLIBVERS: Darwin.POSIXErrorCode">
				<Static="False">
			</Property>
			<Property>
				<name="ESHUTDOWN">
				<signature="static var ESHUTDOWN: Darwin.POSIXErrorCode">
				<Static="False">
			</Property>
			<Property>
				<name="ESOCKTNOSUPPORT">
				<signature="static var ESOCKTNOSUPPORT: Darwin.POSIXErrorCode">
				<Static="False">
			</Property>
			<Property>
				<name="ESPIPE">
				<signature="static var ESPIPE: Darwin.POSIXErrorCode">
				<Static="False">
			</Property>
			<Property>
				<name="ESRCH">
				<signature="static var ESRCH: Darwin.POSIXErrorCode">
				<Static="False">
			</Property>
			<Property>
				<name="ESTALE">
				<signature="static var ESTALE: Darwin.POSIXErrorCode">
				<Static="False">
			</Property>
			<Property>
				<name="ETIME">
				<signature="static var ETIME: Darwin.POSIXErrorCode">
				<Static="False">
			</Property>
			<Property>
				<name="ETIMEDOUT">
				<signature="static var ETIMEDOUT: Darwin.POSIXErrorCode">
				<Static="False">
			</Property>
			<Property>
				<name="ETOOMANYREFS">
				<signature="static var ETOOMANYREFS: Darwin.POSIXErrorCode">
				<Static="False">
			</Property>
			<Property>
				<name="ETXTBSY">
				<signature="static var ETXTBSY: Darwin.POSIXErrorCode">
				<Static="False">
			</Property>
			<Property>
				<name="EUSERS">
				<signature="static var EUSERS: Darwin.POSIXErrorCode">
				<Static="False">
			</Property>
			<Property>
				<name="EWOULDBLOCK">
				<signature="static var EWOULDBLOCK: Darwin.POSIXErrorCode">
				<Static="False">
			</Property>
			<Property>
				<name="EXDEV">
				<signature="static var EXDEV: Darwin.POSIXErrorCode">
				<Static="False">
			</Property>
			<Property>
				<name="errorDomain">
				<signature="static var errorDomain: Swift.String">
				<Static="False">
			</Property>
			<Property>
				<name="hashValue">
				<signature="var hashValue: Int">
				<Static="False">
			</Property>
		</Struct>
		<Struct name="Foundation.PersonNameComponents">
			<Property>
				<name="customMirror">
				<signature="var customMirror: Swift.Mirror">
				<Static="False">
			</Property>
			<Property>
				<name="debugDescription">
				<signature="var debugDescription: Swift.String">
				<Static="False">
			</Property>
			<Property>
				<name="description">
				<signature="var description: Swift.String">
				<Static="False">
			</Property>
			<Property>
				<name="familyName">
				<signature="var familyName: String?">
				<Static="False">
			</Property>
			<Property>
				<name="givenName">
				<signature="var givenName: String?">
				<Static="False">
			</Property>
			<Property>
				<name="hashValue">
				<signature="var hashValue: Int">
				<Static="False">
			</Property>
			<Property>
				<name="middleName">
				<signature="var middleName: String?">
				<Static="False">
			</Property>
			<Property>
				<name="namePrefix">
				<signature="var namePrefix: String?">
				<Static="False">
			</Property>
			<Property>
				<name="nameSuffix">
				<signature="var nameSuffix: String?">
				<Static="False">
			</Property>
			<Property>
				<name="nickname">
				<signature="var nickname: String?">
				<Static="False">
			</Property>
			<Property>
				<name="phoneticRepresentation">
				<signature="var phoneticRepresentation: Foundation.PersonNameComponents?">
				<Static="False">
			</Property>
			<Method>
				<name="==">
				<signature="static func ==(Foundation.PersonNameComponents, Foundation.PersonNameComponents) -> Bool">
				<isStatic="True">
				<returnType="Bool">
				<Parameters>
					<Parameter="Foundation.PersonNameComponents">
					<Parameter="Foundation.PersonNameComponents">
				</Parameters>
			</Method>
			<Method>
				<name="encode">
				<signature="func encode(to: Swift.Encoder)">
				<isStatic="False">
				<returnType="()">
				<Parameters>
					<Parameter="to: Swift.Encoder">
				</Parameters>
			</Method>
			<Method>
				<name="hash">
				<signature="func hash(into: Swift.Hasher)">
				<isStatic="False">
				<returnType="()">
				<Parameters>
					<Parameter="into: Swift.Hasher">
				</Parameters>
			</Method>
		</Struct>
		<Struct name="Foundation.TimeZone">
			<Property>
				<name="abbreviationDictionary">
				<signature="static var abbreviationDictionary: Swift.Dictionary(Swift.String, Swift.String)">
				<Static="False">
			</Property>
			<Property>
				<name="autoupdatingCurrent">
				<signature="static var autoupdatingCurrent: Foundation.TimeZone">
				<Static="False">
			</Property>
			<Property>
				<name="current">
				<signature="static var current: Foundation.TimeZone">
				<Static="False">
			</Property>
			<Property>
				<name="customMirror">
				<signature="var customMirror: Swift.Mirror">
				<Static="False">
			</Property>
			<Property>
				<name="data">
				<signature="var data: Foundation.Data">
				<Static="False">
			</Property>
			<Property>
				<name="debugDescription">
				<signature="var debugDescription: Swift.String">
				<Static="False">
			</Property>
			<Property>
				<name="description">
				<signature="var description: Swift.String">
				<Static="False">
			</Property>
			<Property>
				<name="hashValue">
				<signature="var hashValue: Int">
				<Static="False">
			</Property>
			<Property>
				<name="identifier">
				<signature="var identifier: Swift.String">
				<Static="False">
			</Property>
			<Property>
				<name="knownTimeZoneIdentifiers">
				<signature="static var knownTimeZoneIdentifiers: Swift.Array(Swift.String)">
				<Static="False">
			</Property>
			<Property>
				<name="name">
				<signature="var name: Swift.String">
				<Static="False">
			</Property>
			<Property>
				<name="nextDaylightSavingTimeTransition">
				<signature="var nextDaylightSavingTimeTransition: Foundation.Date?">
				<Static="False">
			</Property>
			<Property>
				<name="timeZoneDataVersion">
				<signature="static var timeZoneDataVersion: Swift.String">
				<Static="False">
			</Property>
			<Method>
				<name="==">
				<signature="static func ==(Foundation.TimeZone, Foundation.TimeZone) -> Bool">
				<isStatic="True">
				<returnType="Bool">
				<Parameters>
					<Parameter="Foundation.TimeZone">
					<Parameter="Foundation.TimeZone">
				</Parameters>
			</Method>
			<Method>
				<name="abbreviation">
				<signature="func abbreviation(for: Foundation.Date) -> String?">
				<isStatic="False">
				<returnType="Swift.Optional<Swift.String>">
				<Parameters>
					<Parameter="for: Foundation.Date">
				</Parameters>
			</Method>
			<Method>
				<name="daylightSavingTimeOffset">
				<signature="func daylightSavingTimeOffset(for: Foundation.Date) -> Double">
				<isStatic="False">
				<returnType="Double">
				<Parameters>
					<Parameter="for: Foundation.Date">
				</Parameters>
			</Method>
			<Method>
				<name="encode">
				<signature="func encode(to: Swift.Encoder)">
				<isStatic="False">
				<returnType="()">
				<Parameters>
					<Parameter="to: Swift.Encoder">
				</Parameters>
			</Method>
			<Method>
				<name="hash">
				<signature="func hash(into: Swift.Hasher)">
				<isStatic="False">
				<returnType="()">
				<Parameters>
					<Parameter="into: Swift.Hasher">
				</Parameters>
			</Method>
			<Method>
				<name="isDaylightSavingTime">
				<signature="func isDaylightSavingTime(for: Foundation.Date) -> Bool">
				<isStatic="False">
				<returnType="Bool">
				<Parameters>
					<Parameter="for: Foundation.Date">
				</Parameters>
			</Method>
			<Method>
				<name="nextDaylightSavingTimeTransition">
				<signature="func nextDaylightSavingTimeTransition(after: Foundation.Date) -> Foundation.Date?">
				<isStatic="False">
				<returnType="Swift.Optional<Foundation.Date>">
				<Parameters>
					<Parameter="after: Foundation.Date">
				</Parameters>
			</Method>
			<Method>
				<name="secondsFromGMT">
				<signature="func secondsFromGMT(for: Foundation.Date) -> Int">
				<isStatic="False">
				<returnType="Int">
				<Parameters>
					<Parameter="for: Foundation.Date">
				</Parameters>
			</Method>
		</Struct>
		<Struct name="Foundation.URL">
			<Property>
				<name="absoluteString">
				<signature="var absoluteString: Swift.String">
				<Static="False">
			</Property>
			<Property>
				<name="absoluteURL">
				<signature="var absoluteURL: Foundation.URL">
				<Static="False">
			</Property>
			<Property>
				<name="baseURL">
				<signature="var baseURL: Foundation.URL?">
				<Static="False">
			</Property>
			<Property>
				<name="dataRepresentation">
				<signature="var dataRepresentation: Foundation.Data">
				<Static="False">
			</Property>
			<Property>
				<name="debugDescription">
				<signature="var debugDescription: Swift.String">
				<Static="False">
			</Property>
			<Property>
				<name="description">
				<signature="var description: Swift.String">
				<Static="False">
			</Property>
			<Property>
				<name="fragment">
				<signature="var fragment: String?">
				<Static="False">
			</Property>
			<Property>
				<name="hasDirectoryPath">
				<signature="var hasDirectoryPath: Bool">
				<Static="False">
			</Property>
			<Property>
				<name="hashValue">
				<signature="var hashValue: Int">
				<Static="False">
			</Property>
			<Property>
				<name="host">
				<signature="var host: String?">
				<Static="False">
			</Property>
			<Property>
				<name="isFileURL">
				<signature="var isFileURL: Bool">
				<Static="False">
			</Property>
			<Property>
				<name="lastPathComponent">
				<signature="var lastPathComponent: Swift.String">
				<Static="False">
			</Property>
			<Property>
				<name="parameterString">
				<signature="var parameterString: String?">
				<Static="False">
			</Property>
			<Property>
				<name="password">
				<signature="var password: String?">
				<Static="False">
			</Property>
			<Property>
				<name="path">
				<signature="var path: Swift.String">
				<Static="False">
			</Property>
			<Property>
				<name="pathComponents">
				<signature="var pathComponents: Swift.Array(Swift.String)">
				<Static="False">
			</Property>
			<Property>
				<name="pathExtension">
				<signature="var pathExtension: Swift.String">
				<Static="False">
			</Property>
			<Property>
				<name="port">
				<signature="var port: Int?">
				<Static="False">
			</Property>
			<Property>
				<name="query">
				<signature="var query: String?">
				<Static="False">
			</Property>
			<Property>
				<name="relativePath">
				<signature="var relativePath: Swift.String">
				<Static="False">
			</Property>
			<Property>
				<name="relativeString">
				<signature="var relativeString: Swift.String">
				<Static="False">
			</Property>
			<Property>
				<name="resourceSpecifier">
				<signature="var resourceSpecifier: Swift.String">
				<Static="False">
			</Property>
			<Property>
				<name="scheme">
				<signature="var scheme: String?">
				<Static="False">
			</Property>
			<Property>
				<name="standardized">
				<signature="var standardized: Foundation.URL">
				<Static="False">
			</Property>
			<Property>
				<name="standardizedFileURL">
				<signature="var standardizedFileURL: Foundation.URL">
				<Static="False">
			</Property>
			<Property>
				<name="user">
				<signature="var user: String?">
				<Static="False">
			</Property>
			<Method>
				<name="==">
				<signature="static func ==(Foundation.URL, Foundation.URL) -> Bool">
				<isStatic="True">
				<returnType="Bool">
				<Parameters>
					<Parameter="Foundation.URL">
					<Parameter="Foundation.URL">
				</Parameters>
			</Method>
			<Method>
				<name="appendPathComponent">
				<signature="func appendPathComponent(: Swift.String, isDirectory: Bool)">
				<isStatic="False">
				<returnType="()">
				<Parameters>
					<Parameter=": Swift.String">
					<Parameter="isDirectory: Bool">
				</Parameters>
			</Method>
			<Method>
				<name="appendPathExtension">
				<signature="func appendPathExtensionSwift.String">
				<isStatic="False">
				<returnType="()">
				<Parameters>
				</Parameters>
			</Method>
			<Method>
				<name="appendingPathComponent">
				<signature="func appendingPathComponent(: Swift.String, isDirectory: Bool) -> Foundation.URL">
				<isStatic="False">
				<returnType="Foundation.URL">
				<Parameters>
					<Parameter=": Swift.String">
					<Parameter="isDirectory: Bool">
				</Parameters>
			</Method>
			<Method>
				<name="appendingPathExtension">
				<signature="func appendingPathExtensionSwift.String -> Foundation.URL">
				<isStatic="False">
				<returnType="Foundation.URL">
				<Parameters>
				</Parameters>
			</Method>
			<Method>
				<name="bookmarkData">
				<signature="static func bookmarkData(withContentsOf: Foundation.URL) -> Foundation.Data">
				<isStatic="True">
				<returnType="Foundation.Data">
				<Parameters>
					<Parameter="withContentsOf: Foundation.URL">
				</Parameters>
			</Method>
			<Method>
				<name="checkPromisedItemIsReachable">
				<signature="func checkPromisedItemIsReachable() -> Bool">
				<isStatic="False">
				<returnType="Bool">
				<Parameters>
					<Parameter="">
				</Parameters>
			</Method>
			<Method>
				<name="checkResourceIsReachable">
				<signature="func checkResourceIsReachable() -> Bool">
				<isStatic="False">
				<returnType="Bool">
				<Parameters>
					<Parameter="">
				</Parameters>
			</Method>
			<Method>
				<name="deleteLastPathComponent">
				<signature="func deleteLastPathComponent()">
				<isStatic="False">
				<returnType="()">
				<Parameters>
					<Parameter="">
				</Parameters>
			</Method>
			<Method>
				<name="deletePathExtension">
				<signature="func deletePathExtension()">
				<isStatic="False">
				<returnType="()">
				<Parameters>
					<Parameter="">
				</Parameters>
			</Method>
			<Method>
				<name="deletingLastPathComponent">
				<signature="func deletingLastPathComponent() -> Foundation.URL">
				<isStatic="False">
				<returnType="Foundation.URL">
				<Parameters>
					<Parameter="">
				</Parameters>
			</Method>
			<Method>
				<name="deletingPathExtension">
				<signature="func deletingPathExtension() -> Foundation.URL">
				<isStatic="False">
				<returnType="Foundation.URL">
				<Parameters>
					<Parameter="">
				</Parameters>
			</Method>
			<Method>
				<name="encode">
				<signature="func encode(to: Swift.Encoder)">
				<isStatic="False">
				<returnType="()">
				<Parameters>
					<Parameter="to: Swift.Encoder">
				</Parameters>
			</Method>
			<Method>
				<name="hash">
				<signature="func hash(into: Swift.Hasher)">
				<isStatic="False">
				<returnType="()">
				<Parameters>
					<Parameter="into: Swift.Hasher">
				</Parameters>
			</Method>
			<Method>
				<name="removeAllCachedResourceValues">
				<signature="func removeAllCachedResourceValues()">
				<isStatic="False">
				<returnType="()">
				<Parameters>
					<Parameter="">
				</Parameters>
			</Method>
			<Method>
				<name="resolveSymlinksInPath">
				<signature="func resolveSymlinksInPath()">
				<isStatic="False">
				<returnType="()">
				<Parameters>
					<Parameter="">
				</Parameters>
			</Method>
			<Method>
				<name="resolvingSymlinksInPath">
				<signature="func resolvingSymlinksInPath() -> Foundation.URL">
				<isStatic="False">
				<returnType="Foundation.URL">
				<Parameters>
					<Parameter="">
				</Parameters>
			</Method>
			<Method>
				<name="setResourceValues">
				<signature="func setResourceValuesFoundation.URLResourceValues">
				<isStatic="False">
				<returnType="()">
				<Parameters>
				</Parameters>
			</Method>
			<Method>
				<name="standardize">
				<signature="func standardize()">
				<isStatic="False">
				<returnType="()">
				<Parameters>
					<Parameter="">
				</Parameters>
			</Method>
			<Method>
				<name="startAccessingSecurityScopedResource">
				<signature="func startAccessingSecurityScopedResource() -> Bool">
				<isStatic="False">
				<returnType="Bool">
				<Parameters>
					<Parameter="">
				</Parameters>
			</Method>
			<Method>
				<name="stopAccessingSecurityScopedResource">
				<signature="func stopAccessingSecurityScopedResource()">
				<isStatic="False">
				<returnType="()">
				<Parameters>
					<Parameter="">
				</Parameters>
			</Method>
			<Method>
				<name="withUnsafeFileSystemRepresentation">
				<signature="func withUnsafeFileSystemRepresentationUnsafePointer(Swift.Int8)> -> Self -? Self">
				<isStatic="False">
				<returnType="(0,0)">
				<Parameters>
					<Parameter="Swift.Int8">
				</Parameters>
			</Method>
			<Method>
				<name="writeBookmarkData">
				<signature="static func writeBookmarkData(: Foundation.Data, to: Foundation.URL)">
				<isStatic="True">
				<returnType="()">
				<Parameters>
					<Parameter=": Foundation.Data">
					<Parameter="to: Foundation.URL">
				</Parameters>
			</Method>
		</Struct>
		<Struct name="Foundation.URLComponents">
			<Property>
				<name="customMirror">
				<signature="var customMirror: Swift.Mirror">
				<Static="False">
			</Property>
			<Property>
				<name="debugDescription">
				<signature="var debugDescription: Swift.String">
				<Static="False">
			</Property>
			<Property>
				<name="description">
				<signature="var description: Swift.String">
				<Static="False">
			</Property>
			<Property>
				<name="fragment">
				<signature="var fragment: String?">
				<Static="False">
			</Property>
			<Property>
				<name="hashValue">
				<signature="var hashValue: Int">
				<Static="False">
			</Property>
			<Property>
				<name="host">
				<signature="var host: String?">
				<Static="False">
			</Property>
			<Property>
				<name="password">
				<signature="var password: String?">
				<Static="False">
			</Property>
			<Property>
				<name="path">
				<signature="var path: Swift.String">
				<Static="False">
			</Property>
			<Property>
				<name="percentEncodedFragment">
				<signature="var percentEncodedFragment: String?">
				<Static="False">
			</Property>
			<Property>
				<name="percentEncodedHost">
				<signature="var percentEncodedHost: String?">
				<Static="False">
			</Property>
			<Property>
				<name="percentEncodedPassword">
				<signature="var percentEncodedPassword: String?">
				<Static="False">
			</Property>
			<Property>
				<name="percentEncodedPath">
				<signature="var percentEncodedPath: Swift.String">
				<Static="False">
			</Property>
			<Property>
				<name="percentEncodedQuery">
				<signature="var percentEncodedQuery: String?">
				<Static="False">
			</Property>
			<Property>
				<name="percentEncodedQueryItems">
				<signature="var percentEncodedQueryItems: Array(Foundation.URLQueryItem)?">
				<Static="False">
			</Property>
			<Property>
				<name="percentEncodedUser">
				<signature="var percentEncodedUser: String?">
				<Static="False">
			</Property>
			<Property>
				<name="port">
				<signature="var port: Int?">
				<Static="False">
			</Property>
			<Property>
				<name="query">
				<signature="var query: String?">
				<Static="False">
			</Property>
			<Property>
				<name="queryItems">
				<signature="var queryItems: Array(Foundation.URLQueryItem)?">
				<Static="False">
			</Property>
			<Property>
				<name="rangeOfFragment">
				<signature="var rangeOfFragment: Range(Swift.String.Index)?">
				<Static="False">
			</Property>
			<Property>
				<name="rangeOfHost">
				<signature="var rangeOfHost: Range(Swift.String.Index)?">
				<Static="False">
			</Property>
			<Property>
				<name="rangeOfPassword">
				<signature="var rangeOfPassword: Range(Swift.String.Index)?">
				<Static="False">
			</Property>
			<Property>
				<name="rangeOfPath">
				<signature="var rangeOfPath: Range(Swift.String.Index)?">
				<Static="False">
			</Property>
			<Property>
				<name="rangeOfPort">
				<signature="var rangeOfPort: Range(Swift.String.Index)?">
				<Static="False">
			</Property>
			<Property>
				<name="rangeOfQuery">
				<signature="var rangeOfQuery: Range(Swift.String.Index)?">
				<Static="False">
			</Property>
			<Property>
				<name="rangeOfScheme">
				<signature="var rangeOfScheme: Range(Swift.String.Index)?">
				<Static="False">
			</Property>
			<Property>
				<name="rangeOfUser">
				<signature="var rangeOfUser: Range(Swift.String.Index)?">
				<Static="False">
			</Property>
			<Property>
				<name="scheme">
				<signature="var scheme: String?">
				<Static="False">
			</Property>
			<Property>
				<name="string">
				<signature="var string: String?">
				<Static="False">
			</Property>
			<Property>
				<name="url">
				<signature="var url: Foundation.URL?">
				<Static="False">
			</Property>
			<Property>
				<name="user">
				<signature="var user: String?">
				<Static="False">
			</Property>
			<Method>
				<name="==">
				<signature="static func ==(Foundation.URLComponents, Foundation.URLComponents) -> Bool">
				<isStatic="True">
				<returnType="Bool">
				<Parameters>
					<Parameter="Foundation.URLComponents">
					<Parameter="Foundation.URLComponents">
				</Parameters>
			</Method>
			<Method>
				<name="encode">
				<signature="func encode(to: Swift.Encoder)">
				<isStatic="False">
				<returnType="()">
				<Parameters>
					<Parameter="to: Swift.Encoder">
				</Parameters>
			</Method>
			<Method>
				<name="hash">
				<signature="func hash(into: Swift.Hasher)">
				<isStatic="False">
				<returnType="()">
				<Parameters>
					<Parameter="into: Swift.Hasher">
				</Parameters>
			</Method>
			<Method>
				<name="url">
				<signature="func url(relativeTo: Foundation.URL>) -> Swift.Optional(Foundation.URL?">
				<isStatic="False">
				<returnType="Swift.Optional<Foundation.URL>">
				<Parameters>
					<Parameter="relativeTo: Foundation.URL>">
				</Parameters>
			</Method>
		</Struct>
		<Struct name="Foundation.URLError">
			<Property>
				<name="AppTransportSecurityRequiresSecureConnection">
				<signature="static var AppTransportSecurityRequiresSecureConnection: Foundation.URLError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="BackgroundSessionInUseByAnotherProcess">
				<signature="static var BackgroundSessionInUseByAnotherProcess: Foundation.URLError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="BackgroundSessionRequiresSharedContainer">
				<signature="static var BackgroundSessionRequiresSharedContainer: Foundation.URLError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="BackgroundSessionWasDisconnected">
				<signature="static var BackgroundSessionWasDisconnected: Foundation.URLError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="BadServerResponse">
				<signature="static var BadServerResponse: Foundation.URLError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="BadURL">
				<signature="static var BadURL: Foundation.URLError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="CallIsActive">
				<signature="static var CallIsActive: Foundation.URLError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="Cancelled">
				<signature="static var Cancelled: Foundation.URLError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="CannotCloseFile">
				<signature="static var CannotCloseFile: Foundation.URLError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="CannotConnectToHost">
				<signature="static var CannotConnectToHost: Foundation.URLError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="CannotCreateFile">
				<signature="static var CannotCreateFile: Foundation.URLError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="CannotDecodeContentData">
				<signature="static var CannotDecodeContentData: Foundation.URLError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="CannotDecodeRawData">
				<signature="static var CannotDecodeRawData: Foundation.URLError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="CannotFindHost">
				<signature="static var CannotFindHost: Foundation.URLError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="CannotLoadFromNetwork">
				<signature="static var CannotLoadFromNetwork: Foundation.URLError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="CannotMoveFile">
				<signature="static var CannotMoveFile: Foundation.URLError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="CannotOpenFile">
				<signature="static var CannotOpenFile: Foundation.URLError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="CannotParseResponse">
				<signature="static var CannotParseResponse: Foundation.URLError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="CannotRemoveFile">
				<signature="static var CannotRemoveFile: Foundation.URLError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="CannotWriteToFile">
				<signature="static var CannotWriteToFile: Foundation.URLError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="ClientCertificateRejected">
				<signature="static var ClientCertificateRejected: Foundation.URLError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="ClientCertificateRequired">
				<signature="static var ClientCertificateRequired: Foundation.URLError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="DNSLookupFailed">
				<signature="static var DNSLookupFailed: Foundation.URLError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="DataLengthExceedsMaximum">
				<signature="static var DataLengthExceedsMaximum: Foundation.URLError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="DataNotAllowed">
				<signature="static var DataNotAllowed: Foundation.URLError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="DownloadDecodingFailedMidStream">
				<signature="static var DownloadDecodingFailedMidStream: Foundation.URLError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="DownloadDecodingFailedToComplete">
				<signature="static var DownloadDecodingFailedToComplete: Foundation.URLError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="FileDoesNotExist">
				<signature="static var FileDoesNotExist: Foundation.URLError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="FileIsDirectory">
				<signature="static var FileIsDirectory: Foundation.URLError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="HTTPTooManyRedirects">
				<signature="static var HTTPTooManyRedirects: Foundation.URLError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="InternationalRoamingOff">
				<signature="static var InternationalRoamingOff: Foundation.URLError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="NetworkConnectionLost">
				<signature="static var NetworkConnectionLost: Foundation.URLError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="NoPermissionsToReadFile">
				<signature="static var NoPermissionsToReadFile: Foundation.URLError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="NotConnectedToInternet">
				<signature="static var NotConnectedToInternet: Foundation.URLError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="RedirectToNonExistentLocation">
				<signature="static var RedirectToNonExistentLocation: Foundation.URLError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="RequestBodyStreamExhausted">
				<signature="static var RequestBodyStreamExhausted: Foundation.URLError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="ResourceUnavailable">
				<signature="static var ResourceUnavailable: Foundation.URLError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="SecureConnectionFailed">
				<signature="static var SecureConnectionFailed: Foundation.URLError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="ServerCertificateHasBadDate">
				<signature="static var ServerCertificateHasBadDate: Foundation.URLError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="ServerCertificateHasUnknownRoot">
				<signature="static var ServerCertificateHasUnknownRoot: Foundation.URLError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="ServerCertificateNotYetValid">
				<signature="static var ServerCertificateNotYetValid: Foundation.URLError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="ServerCertificateUntrusted">
				<signature="static var ServerCertificateUntrusted: Foundation.URLError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="TimedOut">
				<signature="static var TimedOut: Foundation.URLError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="Unknown">
				<signature="static var Unknown: Foundation.URLError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="UnsupportedURL">
				<signature="static var UnsupportedURL: Foundation.URLError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="UserAuthenticationRequired">
				<signature="static var UserAuthenticationRequired: Foundation.URLError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="UserCancelledAuthentication">
				<signature="static var UserCancelledAuthentication: Foundation.URLError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="ZeroByteResource">
				<signature="static var ZeroByteResource: Foundation.URLError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="appTransportSecurityRequiresSecureConnection">
				<signature="static var appTransportSecurityRequiresSecureConnection: Foundation.URLError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="backgroundSessionInUseByAnotherProcess">
				<signature="static var backgroundSessionInUseByAnotherProcess: Foundation.URLError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="backgroundSessionRequiresSharedContainer">
				<signature="static var backgroundSessionRequiresSharedContainer: Foundation.URLError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="backgroundSessionWasDisconnected">
				<signature="static var backgroundSessionWasDisconnected: Foundation.URLError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="backgroundTaskCancelledReason">
				<signature="var backgroundTaskCancelledReason: Foundation.URLError.BackgroundTaskCancelledReason?">
				<Static="False">
			</Property>
			<Property>
				<name="badServerResponse">
				<signature="static var badServerResponse: Foundation.URLError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="badURL">
				<signature="static var badURL: Foundation.URLError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="callIsActive">
				<signature="static var callIsActive: Foundation.URLError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="cancelled">
				<signature="static var cancelled: Foundation.URLError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="cannotCloseFile">
				<signature="static var cannotCloseFile: Foundation.URLError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="cannotConnectToHost">
				<signature="static var cannotConnectToHost: Foundation.URLError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="cannotCreateFile">
				<signature="static var cannotCreateFile: Foundation.URLError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="cannotDecodeContentData">
				<signature="static var cannotDecodeContentData: Foundation.URLError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="cannotDecodeRawData">
				<signature="static var cannotDecodeRawData: Foundation.URLError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="cannotFindHost">
				<signature="static var cannotFindHost: Foundation.URLError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="cannotLoadFromNetwork">
				<signature="static var cannotLoadFromNetwork: Foundation.URLError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="cannotMoveFile">
				<signature="static var cannotMoveFile: Foundation.URLError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="cannotOpenFile">
				<signature="static var cannotOpenFile: Foundation.URLError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="cannotParseResponse">
				<signature="static var cannotParseResponse: Foundation.URLError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="cannotRemoveFile">
				<signature="static var cannotRemoveFile: Foundation.URLError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="cannotWriteToFile">
				<signature="static var cannotWriteToFile: Foundation.URLError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="clientCertificateRejected">
				<signature="static var clientCertificateRejected: Foundation.URLError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="clientCertificateRequired">
				<signature="static var clientCertificateRequired: Foundation.URLError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="dataLengthExceedsMaximum">
				<signature="static var dataLengthExceedsMaximum: Foundation.URLError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="dataNotAllowed">
				<signature="static var dataNotAllowed: Foundation.URLError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="dnsLookupFailed">
				<signature="static var dnsLookupFailed: Foundation.URLError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="downloadDecodingFailedMidStream">
				<signature="static var downloadDecodingFailedMidStream: Foundation.URLError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="downloadDecodingFailedToComplete">
				<signature="static var downloadDecodingFailedToComplete: Foundation.URLError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="downloadTaskResumeData">
				<signature="var downloadTaskResumeData: Foundation.Data?">
				<Static="False">
			</Property>
			<Property>
				<name="errorDomain">
				<signature="static var errorDomain: Swift.String">
				<Static="False">
			</Property>
			<Property>
				<name="failingURL">
				<signature="var failingURL: Foundation.URL?">
				<Static="False">
			</Property>
			<Property>
				<name="failureURLString">
				<signature="var failureURLString: String?">
				<Static="False">
			</Property>
			<Property>
				<name="fileDoesNotExist">
				<signature="static var fileDoesNotExist: Foundation.URLError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="fileIsDirectory">
				<signature="static var fileIsDirectory: Foundation.URLError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="hashValue">
				<signature="var hashValue: Int">
				<Static="False">
			</Property>
			<Property>
				<name="httpTooManyRedirects">
				<signature="static var httpTooManyRedirects: Foundation.URLError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="internationalRoamingOff">
				<signature="static var internationalRoamingOff: Foundation.URLError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="networkConnectionLost">
				<signature="static var networkConnectionLost: Foundation.URLError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="networkUnavailableReason">
				<signature="var networkUnavailableReason: Foundation.URLError.NetworkUnavailableReason?">
				<Static="False">
			</Property>
			<Property>
				<name="noPermissionsToReadFile">
				<signature="static var noPermissionsToReadFile: Foundation.URLError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="notConnectedToInternet">
				<signature="static var notConnectedToInternet: Foundation.URLError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="redirectToNonExistentLocation">
				<signature="static var redirectToNonExistentLocation: Foundation.URLError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="requestBodyStreamExhausted">
				<signature="static var requestBodyStreamExhausted: Foundation.URLError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="resourceUnavailable">
				<signature="static var resourceUnavailable: Foundation.URLError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="secureConnectionFailed">
				<signature="static var secureConnectionFailed: Foundation.URLError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="serverCertificateHasBadDate">
				<signature="static var serverCertificateHasBadDate: Foundation.URLError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="serverCertificateHasUnknownRoot">
				<signature="static var serverCertificateHasUnknownRoot: Foundation.URLError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="serverCertificateNotYetValid">
				<signature="static var serverCertificateNotYetValid: Foundation.URLError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="serverCertificateUntrusted">
				<signature="static var serverCertificateUntrusted: Foundation.URLError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="timedOut">
				<signature="static var timedOut: Foundation.URLError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="unknown">
				<signature="static var unknown: Foundation.URLError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="unsupportedURL">
				<signature="static var unsupportedURL: Foundation.URLError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="userAuthenticationRequired">
				<signature="static var userAuthenticationRequired: Foundation.URLError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="userCancelledAuthentication">
				<signature="static var userCancelledAuthentication: Foundation.URLError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="zeroByteResource">
				<signature="static var zeroByteResource: Foundation.URLError.Code">
				<Static="False">
			</Property>
		</Struct>
		<Struct name="Foundation.URLError.Code">
			<Property>
				<name="appTransportSecurityRequiresSecureConnection">
				<signature="static var appTransportSecurityRequiresSecureConnection: Foundation.URLError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="backgroundSessionInUseByAnotherProcess">
				<signature="static var backgroundSessionInUseByAnotherProcess: Foundation.URLError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="backgroundSessionRequiresSharedContainer">
				<signature="static var backgroundSessionRequiresSharedContainer: Foundation.URLError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="backgroundSessionWasDisconnected">
				<signature="static var backgroundSessionWasDisconnected: Foundation.URLError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="badServerResponse">
				<signature="static var badServerResponse: Foundation.URLError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="badURL">
				<signature="static var badURL: Foundation.URLError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="callIsActive">
				<signature="static var callIsActive: Foundation.URLError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="cancelled">
				<signature="static var cancelled: Foundation.URLError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="cannotCloseFile">
				<signature="static var cannotCloseFile: Foundation.URLError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="cannotConnectToHost">
				<signature="static var cannotConnectToHost: Foundation.URLError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="cannotCreateFile">
				<signature="static var cannotCreateFile: Foundation.URLError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="cannotDecodeContentData">
				<signature="static var cannotDecodeContentData: Foundation.URLError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="cannotDecodeRawData">
				<signature="static var cannotDecodeRawData: Foundation.URLError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="cannotFindHost">
				<signature="static var cannotFindHost: Foundation.URLError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="cannotLoadFromNetwork">
				<signature="static var cannotLoadFromNetwork: Foundation.URLError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="cannotMoveFile">
				<signature="static var cannotMoveFile: Foundation.URLError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="cannotOpenFile">
				<signature="static var cannotOpenFile: Foundation.URLError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="cannotParseResponse">
				<signature="static var cannotParseResponse: Foundation.URLError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="cannotRemoveFile">
				<signature="static var cannotRemoveFile: Foundation.URLError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="cannotWriteToFile">
				<signature="static var cannotWriteToFile: Foundation.URLError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="clientCertificateRejected">
				<signature="static var clientCertificateRejected: Foundation.URLError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="clientCertificateRequired">
				<signature="static var clientCertificateRequired: Foundation.URLError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="dataLengthExceedsMaximum">
				<signature="static var dataLengthExceedsMaximum: Foundation.URLError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="dataNotAllowed">
				<signature="static var dataNotAllowed: Foundation.URLError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="dnsLookupFailed">
				<signature="static var dnsLookupFailed: Foundation.URLError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="downloadDecodingFailedMidStream">
				<signature="static var downloadDecodingFailedMidStream: Foundation.URLError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="downloadDecodingFailedToComplete">
				<signature="static var downloadDecodingFailedToComplete: Foundation.URLError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="fileDoesNotExist">
				<signature="static var fileDoesNotExist: Foundation.URLError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="fileIsDirectory">
				<signature="static var fileIsDirectory: Foundation.URLError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="httpTooManyRedirects">
				<signature="static var httpTooManyRedirects: Foundation.URLError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="internationalRoamingOff">
				<signature="static var internationalRoamingOff: Foundation.URLError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="networkConnectionLost">
				<signature="static var networkConnectionLost: Foundation.URLError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="noPermissionsToReadFile">
				<signature="static var noPermissionsToReadFile: Foundation.URLError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="notConnectedToInternet">
				<signature="static var notConnectedToInternet: Foundation.URLError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="rawValue">
				<signature="var rawValue: Int">
				<Static="False">
			</Property>
			<Property>
				<name="redirectToNonExistentLocation">
				<signature="static var redirectToNonExistentLocation: Foundation.URLError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="requestBodyStreamExhausted">
				<signature="static var requestBodyStreamExhausted: Foundation.URLError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="resourceUnavailable">
				<signature="static var resourceUnavailable: Foundation.URLError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="secureConnectionFailed">
				<signature="static var secureConnectionFailed: Foundation.URLError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="serverCertificateHasBadDate">
				<signature="static var serverCertificateHasBadDate: Foundation.URLError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="serverCertificateHasUnknownRoot">
				<signature="static var serverCertificateHasUnknownRoot: Foundation.URLError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="serverCertificateNotYetValid">
				<signature="static var serverCertificateNotYetValid: Foundation.URLError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="serverCertificateUntrusted">
				<signature="static var serverCertificateUntrusted: Foundation.URLError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="timedOut">
				<signature="static var timedOut: Foundation.URLError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="unknown">
				<signature="static var unknown: Foundation.URLError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="unsupportedURL">
				<signature="static var unsupportedURL: Foundation.URLError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="userAuthenticationRequired">
				<signature="static var userAuthenticationRequired: Foundation.URLError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="userCancelledAuthentication">
				<signature="static var userCancelledAuthentication: Foundation.URLError.Code">
				<Static="False">
			</Property>
			<Property>
				<name="zeroByteResource">
				<signature="static var zeroByteResource: Foundation.URLError.Code">
				<Static="False">
			</Property>
		</Struct>
		<Struct name="Foundation.URLQueryItem">
			<Property>
				<name="customMirror">
				<signature="var customMirror: Swift.Mirror">
				<Static="False">
			</Property>
			<Property>
				<name="debugDescription">
				<signature="var debugDescription: Swift.String">
				<Static="False">
			</Property>
			<Property>
				<name="description">
				<signature="var description: Swift.String">
				<Static="False">
			</Property>
			<Property>
				<name="hashValue">
				<signature="var hashValue: Int">
				<Static="False">
			</Property>
			<Property>
				<name="name">
				<signature="var name: Swift.String">
				<Static="False">
			</Property>
			<Property>
				<name="value">
				<signature="var value: String?">
				<Static="False">
			</Property>
			<Method>
				<name="==">
				<signature="static func ==(Foundation.URLQueryItem, Foundation.URLQueryItem) -> Bool">
				<isStatic="True">
				<returnType="Bool">
				<Parameters>
					<Parameter="Foundation.URLQueryItem">
					<Parameter="Foundation.URLQueryItem">
				</Parameters>
			</Method>
			<Method>
				<name="hash">
				<signature="func hash(into: Swift.Hasher)">
				<isStatic="False">
				<returnType="()">
				<Parameters>
					<Parameter="into: Swift.Hasher">
				</Parameters>
			</Method>
		</Struct>
		<Struct name="Foundation.URLRequest">
			<Property>
				<name="allHTTPHeaderFields">
				<signature="var allHTTPHeaderFields: Dictionary(Swift.String, Swift.String)?">
				<Static="False">
			</Property>
			<Property>
				<name="allowsCellularAccess">
				<signature="var allowsCellularAccess: Bool">
				<Static="False">
			</Property>
			<Property>
				<name="allowsConstrainedNetworkAccess">
				<signature="var allowsConstrainedNetworkAccess: Bool">
				<Static="False">
			</Property>
			<Property>
				<name="allowsExpensiveNetworkAccess">
				<signature="var allowsExpensiveNetworkAccess: Bool">
				<Static="False">
			</Property>
			<Property>
				<name="customMirror">
				<signature="var customMirror: Swift.Mirror">
				<Static="False">
			</Property>
			<Property>
				<name="debugDescription">
				<signature="var debugDescription: Swift.String">
				<Static="False">
			</Property>
			<Property>
				<name="description">
				<signature="var description: Swift.String">
				<Static="False">
			</Property>
			<Property>
				<name="hashValue">
				<signature="var hashValue: Int">
				<Static="False">
			</Property>
			<Property>
				<name="httpBody">
				<signature="var httpBody: Foundation.Data?">
				<Static="False">
			</Property>
			<Property>
				<name="httpMethod">
				<signature="var httpMethod: String?">
				<Static="False">
			</Property>
			<Property>
				<name="httpShouldHandleCookies">
				<signature="var httpShouldHandleCookies: Bool">
				<Static="False">
			</Property>
			<Property>
				<name="httpShouldUsePipelining">
				<signature="var httpShouldUsePipelining: Bool">
				<Static="False">
			</Property>
			<Property>
				<name="mainDocumentURL">
				<signature="var mainDocumentURL: Foundation.URL?">
				<Static="False">
			</Property>
			<Property>
				<name="timeoutInterval">
				<signature="var timeoutInterval: Double">
				<Static="False">
			</Property>
			<Property>
				<name="url">
				<signature="var url: Foundation.URL?">
				<Static="False">
			</Property>
			<Method>
				<name="==">
				<signature="static func ==(Foundation.URLRequest, Foundation.URLRequest) -> Bool">
				<isStatic="True">
				<returnType="Bool">
				<Parameters>
					<Parameter="Foundation.URLRequest">
					<Parameter="Foundation.URLRequest">
				</Parameters>
			</Method>
			<Method>
				<name="addValue">
				<signature="func addValue(: Swift.String, forHTTPHeaderField: Swift.String)">
				<isStatic="False">
				<returnType="()">
				<Parameters>
					<Parameter=": Swift.String">
					<Parameter="forHTTPHeaderField: Swift.String">
				</Parameters>
			</Method>
			<Method>
				<name="hash">
				<signature="func hash(into: Swift.Hasher)">
				<isStatic="False">
				<returnType="()">
				<Parameters>
					<Parameter="into: Swift.Hasher">
				</Parameters>
			</Method>
			<Method>
				<name="setValue">
				<signature="func setValue(: String?, forHTTPHeaderField: Swift.String)">
				<isStatic="False">
				<returnType="()">
				<Parameters>
					<Parameter=": String?">
					<Parameter="forHTTPHeaderField: Swift.String">
				</Parameters>
			</Method>
			<Method>
				<name="value">
				<signature="func value(forHTTPHeaderField: Swift.String) -> String?">
				<isStatic="False">
				<returnType="Swift.Optional<Swift.String>">
				<Parameters>
					<Parameter="forHTTPHeaderField: Swift.String">
				</Parameters>
			</Method>
		</Struct>
		<Struct name="Foundation.URLResourceValues">
			<Property>
				<name="addedToDirectoryDate">
				<signature="var addedToDirectoryDate: Foundation.Date?">
				<Static="False">
			</Property>
			<Property>
				<name="attributeModificationDate">
				<signature="var attributeModificationDate: Foundation.Date?">
				<Static="False">
			</Property>
			<Property>
				<name="canonicalPath">
				<signature="var canonicalPath: String?">
				<Static="False">
			</Property>
			<Property>
				<name="contentAccessDate">
				<signature="var contentAccessDate: Foundation.Date?">
				<Static="False">
			</Property>
			<Property>
				<name="contentModificationDate">
				<signature="var contentModificationDate: Foundation.Date?">
				<Static="False">
			</Property>
			<Property>
				<name="creationDate">
				<signature="var creationDate: Foundation.Date?">
				<Static="False">
			</Property>
			<Property>
				<name="documentIdentifier">
				<signature="var documentIdentifier: Int?">
				<Static="False">
			</Property>
			<Property>
				<name="fileAllocatedSize">
				<signature="var fileAllocatedSize: Int?">
				<Static="False">
			</Property>
			<Property>
				<name="fileSize">
				<signature="var fileSize: Int?">
				<Static="False">
			</Property>
			<Property>
				<name="hasHiddenExtension">
				<signature="var hasHiddenExtension: Bool?">
				<Static="False">
			</Property>
			<Property>
				<name="isAliasFile">
				<signature="var isAliasFile: Bool?">
				<Static="False">
			</Property>
			<Property>
				<name="isApplication">
				<signature="var isApplication: Bool?">
				<Static="False">
			</Property>
			<Property>
				<name="isDirectory">
				<signature="var isDirectory: Bool?">
				<Static="False">
			</Property>
			<Property>
				<name="isExcludedFromBackup">
				<signature="var isExcludedFromBackup: Bool?">
				<Static="False">
			</Property>
			<Property>
				<name="isExecutable">
				<signature="var isExecutable: Bool?">
				<Static="False">
			</Property>
			<Property>
				<name="isHidden">
				<signature="var isHidden: Bool?">
				<Static="False">
			</Property>
			<Property>
				<name="isMountTrigger">
				<signature="var isMountTrigger: Bool?">
				<Static="False">
			</Property>
			<Property>
				<name="isPackage">
				<signature="var isPackage: Bool?">
				<Static="False">
			</Property>
			<Property>
				<name="isReadable">
				<signature="var isReadable: Bool?">
				<Static="False">
			</Property>
			<Property>
				<name="isRegularFile">
				<signature="var isRegularFile: Bool?">
				<Static="False">
			</Property>
			<Property>
				<name="isSymbolicLink">
				<signature="var isSymbolicLink: Bool?">
				<Static="False">
			</Property>
			<Property>
				<name="isSystemImmutable">
				<signature="var isSystemImmutable: Bool?">
				<Static="False">
			</Property>
			<Property>
				<name="isUbiquitousItem">
				<signature="var isUbiquitousItem: Bool?">
				<Static="False">
			</Property>
			<Property>
				<name="isUserImmutable">
				<signature="var isUserImmutable: Bool?">
				<Static="False">
			</Property>
			<Property>
				<name="isVolume">
				<signature="var isVolume: Bool?">
				<Static="False">
			</Property>
			<Property>
				<name="isWritable">
				<signature="var isWritable: Bool?">
				<Static="False">
			</Property>
			<Property>
				<name="labelNumber">
				<signature="var labelNumber: Int?">
				<Static="False">
			</Property>
			<Property>
				<name="linkCount">
				<signature="var linkCount: Int?">
				<Static="False">
			</Property>
			<Property>
				<name="localizedLabel">
				<signature="var localizedLabel: String?">
				<Static="False">
			</Property>
			<Property>
				<name="localizedName">
				<signature="var localizedName: String?">
				<Static="False">
			</Property>
			<Property>
				<name="localizedTypeDescription">
				<signature="var localizedTypeDescription: String?">
				<Static="False">
			</Property>
			<Property>
				<name="name">
				<signature="var name: String?">
				<Static="False">
			</Property>
			<Property>
				<name="parentDirectory">
				<signature="var parentDirectory: Foundation.URL?">
				<Static="False">
			</Property>
			<Property>
				<name="path">
				<signature="var path: String?">
				<Static="False">
			</Property>
			<Property>
				<name="preferredIOBlockSize">
				<signature="var preferredIOBlockSize: Int?">
				<Static="False">
			</Property>
			<Property>
				<name="totalFileAllocatedSize">
				<signature="var totalFileAllocatedSize: Int?">
				<Static="False">
			</Property>
			<Property>
				<name="totalFileSize">
				<signature="var totalFileSize: Int?">
				<Static="False">
			</Property>
			<Property>
				<name="typeIdentifier">
				<signature="var typeIdentifier: String?">
				<Static="False">
			</Property>
			<Property>
				<name="ubiquitousItemContainerDisplayName">
				<signature="var ubiquitousItemContainerDisplayName: String?">
				<Static="False">
			</Property>
			<Property>
				<name="ubiquitousItemDownloadRequested">
				<signature="var ubiquitousItemDownloadRequested: Bool?">
				<Static="False">
			</Property>
			<Property>
				<name="ubiquitousItemHasUnresolvedConflicts">
				<signature="var ubiquitousItemHasUnresolvedConflicts: Bool?">
				<Static="False">
			</Property>
			<Property>
				<name="ubiquitousItemIsDownloading">
				<signature="var ubiquitousItemIsDownloading: Bool?">
				<Static="False">
			</Property>
			<Property>
				<name="ubiquitousItemIsShared">
				<signature="var ubiquitousItemIsShared: Bool?">
				<Static="False">
			</Property>
			<Property>
				<name="ubiquitousItemIsUploaded">
				<signature="var ubiquitousItemIsUploaded: Bool?">
				<Static="False">
			</Property>
			<Property>
				<name="ubiquitousItemIsUploading">
				<signature="var ubiquitousItemIsUploading: Bool?">
				<Static="False">
			</Property>
			<Property>
				<name="ubiquitousSharedItemMostRecentEditorNameComponents">
				<signature="var ubiquitousSharedItemMostRecentEditorNameComponents: Foundation.PersonNameComponents?">
				<Static="False">
			</Property>
			<Property>
				<name="ubiquitousSharedItemOwnerNameComponents">
				<signature="var ubiquitousSharedItemOwnerNameComponents: Foundation.PersonNameComponents?">
				<Static="False">
			</Property>
			<Property>
				<name="volume">
				<signature="var volume: Foundation.URL?">
				<Static="False">
			</Property>
			<Property>
				<name="volumeAvailableCapacity">
				<signature="var volumeAvailableCapacity: Int?">
				<Static="False">
			</Property>
			<Property>
				<name="volumeAvailableCapacityForImportantUsage">
				<signature="var volumeAvailableCapacityForImportantUsage: Int64?">
				<Static="False">
			</Property>
			<Property>
				<name="volumeAvailableCapacityForOpportunisticUsage">
				<signature="var volumeAvailableCapacityForOpportunisticUsage: Int64?">
				<Static="False">
			</Property>
			<Property>
				<name="volumeCreationDate">
				<signature="var volumeCreationDate: Foundation.Date?">
				<Static="False">
			</Property>
			<Property>
				<name="volumeIsAutomounted">
				<signature="var volumeIsAutomounted: Bool?">
				<Static="False">
			</Property>
			<Property>
				<name="volumeIsBrowsable">
				<signature="var volumeIsBrowsable: Bool?">
				<Static="False">
			</Property>
			<Property>
				<name="volumeIsEjectable">
				<signature="var volumeIsEjectable: Bool?">
				<Static="False">
			</Property>
			<Property>
				<name="volumeIsEncrypted">
				<signature="var volumeIsEncrypted: Bool?">
				<Static="False">
			</Property>
			<Property>
				<name="volumeIsInternal">
				<signature="var volumeIsInternal: Bool?">
				<Static="False">
			</Property>
			<Property>
				<name="volumeIsJournaling">
				<signature="var volumeIsJournaling: Bool?">
				<Static="False">
			</Property>
			<Property>
				<name="volumeIsLocal">
				<signature="var volumeIsLocal: Bool?">
				<Static="False">
			</Property>
			<Property>
				<name="volumeIsReadOnly">
				<signature="var volumeIsReadOnly: Bool?">
				<Static="False">
			</Property>
			<Property>
				<name="volumeIsRemovable">
				<signature="var volumeIsRemovable: Bool?">
				<Static="False">
			</Property>
			<Property>
				<name="volumeIsRootFileSystem">
				<signature="var volumeIsRootFileSystem: Bool?">
				<Static="False">
			</Property>
			<Property>
				<name="volumeLocalizedFormatDescription">
				<signature="var volumeLocalizedFormatDescription: String?">
				<Static="False">
			</Property>
			<Property>
				<name="volumeLocalizedName">
				<signature="var volumeLocalizedName: String?">
				<Static="False">
			</Property>
			<Property>
				<name="volumeMaximumFileSize">
				<signature="var volumeMaximumFileSize: Int?">
				<Static="False">
			</Property>
			<Property>
				<name="volumeName">
				<signature="var volumeName: String?">
				<Static="False">
			</Property>
			<Property>
				<name="volumeResourceCount">
				<signature="var volumeResourceCount: Int?">
				<Static="False">
			</Property>
			<Property>
				<name="volumeSupportsAccessPermissions">
				<signature="var volumeSupportsAccessPermissions: Bool?">
				<Static="False">
			</Property>
			<Property>
				<name="volumeSupportsAdvisoryFileLocking">
				<signature="var volumeSupportsAdvisoryFileLocking: Bool?">
				<Static="False">
			</Property>
			<Property>
				<name="volumeSupportsCasePreservedNames">
				<signature="var volumeSupportsCasePreservedNames: Bool?">
				<Static="False">
			</Property>
			<Property>
				<name="volumeSupportsCaseSensitiveNames">
				<signature="var volumeSupportsCaseSensitiveNames: Bool?">
				<Static="False">
			</Property>
			<Property>
				<name="volumeSupportsCompression">
				<signature="var volumeSupportsCompression: Bool?">
				<Static="False">
			</Property>
			<Property>
				<name="volumeSupportsExclusiveRenaming">
				<signature="var volumeSupportsExclusiveRenaming: Bool?">
				<Static="False">
			</Property>
			<Property>
				<name="volumeSupportsExtendedSecurity">
				<signature="var volumeSupportsExtendedSecurity: Bool?">
				<Static="False">
			</Property>
			<Property>
				<name="volumeSupportsFileCloning">
				<signature="var volumeSupportsFileCloning: Bool?">
				<Static="False">
			</Property>
			<Property>
				<name="volumeSupportsHardLinks">
				<signature="var volumeSupportsHardLinks: Bool?">
				<Static="False">
			</Property>
			<Property>
				<name="volumeSupportsImmutableFiles">
				<signature="var volumeSupportsImmutableFiles: Bool?">
				<Static="False">
			</Property>
			<Property>
				<name="volumeSupportsJournaling">
				<signature="var volumeSupportsJournaling: Bool?">
				<Static="False">
			</Property>
			<Property>
				<name="volumeSupportsPersistentIDs">
				<signature="var volumeSupportsPersistentIDs: Bool?">
				<Static="False">
			</Property>
			<Property>
				<name="volumeSupportsRenaming">
				<signature="var volumeSupportsRenaming: Bool?">
				<Static="False">
			</Property>
			<Property>
				<name="volumeSupportsRootDirectoryDates">
				<signature="var volumeSupportsRootDirectoryDates: Bool?">
				<Static="False">
			</Property>
			<Property>
				<name="volumeSupportsSparseFiles">
				<signature="var volumeSupportsSparseFiles: Bool?">
				<Static="False">
			</Property>
			<Property>
				<name="volumeSupportsSwapRenaming">
				<signature="var volumeSupportsSwapRenaming: Bool?">
				<Static="False">
			</Property>
			<Property>
				<name="volumeSupportsSymbolicLinks">
				<signature="var volumeSupportsSymbolicLinks: Bool?">
				<Static="False">
			</Property>
			<Property>
				<name="volumeSupportsVolumeSizes">
				<signature="var volumeSupportsVolumeSizes: Bool?">
				<Static="False">
			</Property>
			<Property>
				<name="volumeSupportsZeroRuns">
				<signature="var volumeSupportsZeroRuns: Bool?">
				<Static="False">
			</Property>
			<Property>
				<name="volumeTotalCapacity">
				<signature="var volumeTotalCapacity: Int?">
				<Static="False">
			</Property>
			<Property>
				<name="volumeURLForRemounting">
				<signature="var volumeURLForRemounting: Foundation.URL?">
				<Static="False">
			</Property>
			<Property>
				<name="volumeUUIDString">
				<signature="var volumeUUIDString: String?">
				<Static="False">
			</Property>
		</Struct>
		<Struct name="Foundation.UUID">
			<Property>
				<name="customMirror">
				<signature="var customMirror: Swift.Mirror">
				<Static="False">
			</Property>
			<Property>
				<name="debugDescription">
				<signature="var debugDescription: Swift.String">
				<Static="False">
			</Property>
			<Property>
				<name="description">
				<signature="var description: Swift.String">
				<Static="False">
			</Property>
			<Property>
				<name="hashValue">
				<signature="var hashValue: Int">
				<Static="False">
			</Property>
			<Property>
				<name="uuid">
				<signature="var uuid: (Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8)">
				<Static="False">
			</Property>
			<Property>
				<name="uuidString">
				<signature="var uuidString: Swift.String">
				<Static="False">
			</Property>
			<Method>
				<name="==">
				<signature="static func ==(Foundation.UUID, Foundation.UUID) -> Bool">
				<isStatic="True">
				<returnType="Bool">
				<Parameters>
					<Parameter="Foundation.UUID">
					<Parameter="Foundation.UUID">
				</Parameters>
			</Method>
			<Method>
				<name="encode">
				<signature="func encode(to: Swift.Encoder)">
				<isStatic="False">
				<returnType="()">
				<Parameters>
					<Parameter="to: Swift.Encoder">
				</Parameters>
			</Method>
			<Method>
				<name="hash">
				<signature="func hash(into: Swift.Hasher)">
				<isStatic="False">
				<returnType="()">
				<Parameters>
					<Parameter="into: Swift.Hasher">
				</Parameters>
			</Method>
		</Struct>
		<Struct name="Swift.AnyHashable">
		</Struct>
		<Struct name="Swift.Array">
		</Struct>
		<Struct name="Swift.Bool">
		</Struct>
		<Struct name="Swift.CollectionDifference">
		</Struct>
		<Struct name="Swift.Dictionary">
		</Struct>
		<Struct name="Swift.Double">
		</Struct>
		<Struct name="Swift.Float">
		</Struct>
		<Struct name="Swift.Int">
		</Struct>
		<Struct name="Swift.Int16">
		</Struct>
		<Struct name="Swift.Int32">
		</Struct>
		<Struct name="Swift.Int64">
		</Struct>
		<Struct name="Swift.Int8">
		</Struct>
		<Struct name="Swift.Set">
		</Struct>
		<Struct name="Swift.String">
			<Property>
				<name="ascii">
				<signature="static var ascii: Swift.String">
				<Static="False">
			</Property>
			<Property>
				<name="description">
				<signature="var description: Swift.String">
				<Static="False">
			</Property>
			<Property>
				<name="hashValue">
				<signature="var hashValue: Int">
				<Static="False">
			</Property>
			<Property>
				<name="iso2022JP">
				<signature="static var iso2022JP: Swift.String">
				<Static="False">
			</Property>
			<Property>
				<name="isoLatin1">
				<signature="static var isoLatin1: Swift.String">
				<Static="False">
			</Property>
			<Property>
				<name="isoLatin2">
				<signature="static var isoLatin2: Swift.String">
				<Static="False">
			</Property>
			<Property>
				<name="japaneseEUC">
				<signature="static var japaneseEUC: Swift.String">
				<Static="False">
			</Property>
			<Property>
				<name="macOSRoman">
				<signature="static var macOSRoman: Swift.String">
				<Static="False">
			</Property>
			<Property>
				<name="nextstep">
				<signature="static var nextstep: Swift.String">
				<Static="False">
			</Property>
			<Property>
				<name="nonLossyASCII">
				<signature="static var nonLossyASCII: Swift.String">
				<Static="False">
			</Property>
			<Property>
				<name="rawValue">
				<signature="var rawValue: UInt">
				<Static="False">
			</Property>
			<Property>
				<name="shiftJIS">
				<signature="static var shiftJIS: Swift.String">
				<Static="False">
			</Property>
			<Property>
				<name="symbol">
				<signature="static var symbol: Swift.String">
				<Static="False">
			</Property>
			<Property>
				<name="unicode">
				<signature="static var unicode: Swift.String">
				<Static="False">
			</Property>
			<Property>
				<name="utf16">
				<signature="static var utf16: Swift.String">
				<Static="False">
			</Property>
			<Property>
				<name="utf16BigEndian">
				<signature="static var utf16BigEndian: Swift.String">
				<Static="False">
			</Property>
			<Property>
				<name="utf16LittleEndian">
				<signature="static var utf16LittleEndian: Swift.String">
				<Static="False">
			</Property>
			<Property>
				<name="utf32">
				<signature="static var utf32: Swift.String">
				<Static="False">
			</Property>
			<Property>
				<name="utf32BigEndian">
				<signature="static var utf32BigEndian: Swift.String">
				<Static="False">
			</Property>
			<Property>
				<name="utf32LittleEndian">
				<signature="static var utf32LittleEndian: Swift.String">
				<Static="False">
			</Property>
			<Property>
				<name="utf8">
				<signature="static var utf8: Swift.String">
				<Static="False">
			</Property>
			<Property>
				<name="windowsCP1250">
				<signature="static var windowsCP1250: Swift.String">
				<Static="False">
			</Property>
			<Property>
				<name="windowsCP1251">
				<signature="static var windowsCP1251: Swift.String">
				<Static="False">
			</Property>
			<Property>
				<name="windowsCP1252">
				<signature="static var windowsCP1252: Swift.String">
				<Static="False">
			</Property>
			<Property>
				<name="windowsCP1253">
				<signature="static var windowsCP1253: Swift.String">
				<Static="False">
			</Property>
			<Property>
				<name="windowsCP1254">
				<signature="static var windowsCP1254: Swift.String">
				<Static="False">
			</Property>
			<Method>
				<name="==">
				<signature="static func ==(Swift.String, Swift.String) -> Bool">
				<isStatic="True">
				<returnType="Bool">
				<Parameters>
					<Parameter="Swift.String">
					<Parameter="Swift.String">
				</Parameters>
			</Method>
		</Struct>
		<Struct name="Swift.String">
		</Struct>
		<Struct name="Swift.Substring">
		</Struct>
		<Struct name="Swift.UInt">
		</Struct>
		<Struct name="Swift.UInt16">
		</Struct>
		<Struct name="Swift.UInt32">
		</Struct>
		<Struct name="Swift.UInt64">
		</Struct>
		<Struct name="Swift.UInt8">
		</Struct>
		<Struct name="Swift.UnsafeMutableRawBufferPointer">
		</Struct>
		<Struct name="Swift.UnsafeRawBufferPointer">
		</Struct>
	</Structs>
	<Enums>
		<Enum name="Darwin.MachErrorCode">
		</Enum>
		<Enum name="Darwin.POSIXErrorCode">
		</Enum>
		<Enum name="Foundation.Calendar.Component">
			<Property>
				<name="hashValue">
				<signature="var hashValue: Int">
				<Static="False">
			</Property>
			<Method>
				<name="==">
				<signature="static func ==(Foundation.Calendar.Component, Foundation.Calendar.Component) -> Bool">
				<isStatic="True">
				<returnType="Bool">
				<Parameters>
					<Parameter="Foundation.Calendar.Component">
					<Parameter="Foundation.Calendar.Component">
				</Parameters>
			</Method>
			<Method>
				<name="hash">
				<signature="func hash(into: Swift.Hasher)">
				<isStatic="False">
				<returnType="()">
				<Parameters>
					<Parameter="into: Swift.Hasher">
				</Parameters>
			</Method>
		</Enum>
		<Enum name="Foundation.Calendar.Identifier">
			<Property>
				<name="hashValue">
				<signature="var hashValue: Int">
				<Static="False">
			</Property>
			<Method>
				<name="==">
				<signature="static func ==(Foundation.Calendar.Identifier, Foundation.Calendar.Identifier) -> Bool">
				<isStatic="True">
				<returnType="Bool">
				<Parameters>
					<Parameter="Foundation.Calendar.Identifier">
					<Parameter="Foundation.Calendar.Identifier">
				</Parameters>
			</Method>
			<Method>
				<name="hash">
				<signature="func hash(into: Swift.Hasher)">
				<isStatic="False">
				<returnType="()">
				<Parameters>
					<Parameter="into: Swift.Hasher">
				</Parameters>
			</Method>
		</Enum>
		<Enum name="Foundation.Calendar.MatchingPolicy">
			<Property>
				<name="hashValue">
				<signature="var hashValue: Int">
				<Static="False">
			</Property>
			<Method>
				<name="==">
				<signature="static func ==(Foundation.Calendar.MatchingPolicy, Foundation.Calendar.MatchingPolicy) -> Bool">
				<isStatic="True">
				<returnType="Bool">
				<Parameters>
					<Parameter="Foundation.Calendar.MatchingPolicy">
					<Parameter="Foundation.Calendar.MatchingPolicy">
				</Parameters>
			</Method>
			<Method>
				<name="hash">
				<signature="func hash(into: Swift.Hasher)">
				<isStatic="False">
				<returnType="()">
				<Parameters>
					<Parameter="into: Swift.Hasher">
				</Parameters>
			</Method>
		</Enum>
		<Enum name="Foundation.Calendar.RepeatedTimePolicy">
			<Property>
				<name="hashValue">
				<signature="var hashValue: Int">
				<Static="False">
			</Property>
			<Method>
				<name="==">
				<signature="static func ==(Foundation.Calendar.RepeatedTimePolicy, Foundation.Calendar.RepeatedTimePolicy) -> Bool">
				<isStatic="True">
				<returnType="Bool">
				<Parameters>
					<Parameter="Foundation.Calendar.RepeatedTimePolicy">
					<Parameter="Foundation.Calendar.RepeatedTimePolicy">
				</Parameters>
			</Method>
			<Method>
				<name="hash">
				<signature="func hash(into: Swift.Hasher)">
				<isStatic="False">
				<returnType="()">
				<Parameters>
					<Parameter="into: Swift.Hasher">
				</Parameters>
			</Method>
		</Enum>
		<Enum name="Foundation.Calendar.SearchDirection">
			<Property>
				<name="hashValue">
				<signature="var hashValue: Int">
				<Static="False">
			</Property>
			<Method>
				<name="==">
				<signature="static func ==(Foundation.Calendar.SearchDirection, Foundation.Calendar.SearchDirection) -> Bool">
				<isStatic="True">
				<returnType="Bool">
				<Parameters>
					<Parameter="Foundation.Calendar.SearchDirection">
					<Parameter="Foundation.Calendar.SearchDirection">
				</Parameters>
			</Method>
			<Method>
				<name="hash">
				<signature="func hash(into: Swift.Hasher)">
				<isStatic="False">
				<returnType="()">
				<Parameters>
					<Parameter="into: Swift.Hasher">
				</Parameters>
			</Method>
		</Enum>
		<Enum name="Foundation.Data.Deallocator">
		</Enum>
		<Enum name="Foundation.JSONDecoder.DataDecodingStrategy">
		</Enum>
		<Enum name="Foundation.JSONDecoder.DateDecodingStrategy">
		</Enum>
		<Enum name="Foundation.JSONDecoder.KeyDecodingStrategy">
		</Enum>
		<Enum name="Foundation.JSONDecoder.NonConformingFloatDecodingStrategy">
		</Enum>
		<Enum name="Foundation.JSONEncoder.DataEncodingStrategy">
		</Enum>
		<Enum name="Foundation.JSONEncoder.DateEncodingStrategy">
		</Enum>
		<Enum name="Foundation.JSONEncoder.KeyEncodingStrategy">
		</Enum>
		<Enum name="Foundation.JSONEncoder.NonConformingFloatEncodingStrategy">
		</Enum>
		<Enum name="Foundation.URLError.BackgroundTaskCancelledReason">
			<Property>
				<name="rawValue">
				<signature="var rawValue: Int">
				<Static="False">
			</Property>
		</Enum>
		<Enum name="Foundation.URLError.NetworkUnavailableReason">
			<Property>
				<name="rawValue">
				<signature="var rawValue: Int">
				<Static="False">
			</Property>
		</Enum>
		<Enum name="Swift.DecodingError">
		</Enum>
		<Enum name="Swift.EncodingError">
		</Enum>
	</Enums>
	<Protocols>
		<Protocol name="Foundation.ContiguousBytes">
			<Method>
				<name="withUnsafeBytes">
				<signature="func withUnsafeBytesSwift.UnsafeRawBufferPointer -> ??? -> ???">
				<isStatic="False">
			</Method>
		</Protocol>
		<Protocol name="Foundation.CustomNSError">
			<Method>
				<name="errorCode">
				<signature="func errorCode() -> Int">
				<isStatic="False">
			</Method>
			<Method>
				<name="errorDomain">
				<signature="func errorDomain() -> Swift.String">
				<isStatic="False">
			</Method>
			<Method>
				<name="errorUserInfo">
				<signature="func errorUserInfo() -> Swift.Dictionary(Swift.String, Swift.Any)">
				<isStatic="False">
			</Method>
		</Protocol>
		<Protocol name="Foundation.DataProtocol">
			<Method>
				<name="copyBytes">
				<signature="func copyBytes(to: Swift.UnsafeMutableBufferPointer(???), from: ???) -> Int">
				<isStatic="False">
			</Method>
			<Method>
				<name="copyBytes">
				<signature="func copyBytes(to: Swift.UnsafeMutableRawBufferPointer, from: ???) -> Int">
				<isStatic="False">
			</Method>
			<Method>
				<name="copyBytes">
				<signature="func copyBytes(to: Swift.UnsafeMutableBufferPointer(???), count: Int) -> Int">
				<isStatic="False">
			</Method>
			<Method>
				<name="copyBytes">
				<signature="func copyBytes(to: Swift.UnsafeMutableRawBufferPointer, count: Int) -> Int">
				<isStatic="False">
			</Method>
			<Method>
				<name="firstRange">
				<signature="func firstRange(of: ???, in: ???) -> Range(Self.Index)?">
				<isStatic="False">
			</Method>
			<Method>
				<name="lastRange">
				<signature="func lastRange(of: ???, in: ???) -> Range(Self.Index)?">
				<isStatic="False">
			</Method>
			<Method>
				<name="regions">
				<signature="func regions() -> Self.Regions">
				<isStatic="False">
			</Method>
		</Protocol>
		<Protocol name="Foundation.LocalizedError">
			<Method>
				<name="errorDescription">
				<signature="func errorDescription() -> String?">
				<isStatic="False">
			</Method>
			<Method>
				<name="failureReason">
				<signature="func failureReason() -> String?">
				<isStatic="False">
			</Method>
			<Method>
				<name="helpAnchor">
				<signature="func helpAnchor() -> String?">
				<isStatic="False">
			</Method>
			<Method>
				<name="recoverySuggestion">
				<signature="func recoverySuggestion() -> String?">
				<isStatic="False">
			</Method>
		</Protocol>
		<Protocol name="Foundation.MutableDataProtocol">
			<Method>
				<name="resetBytes">
				<signature="func resetBytes(in: ???)">
				<isStatic="False">
			</Method>
		</Protocol>
		<Protocol name="Foundation.NSKeyValueObservingCustomization">
			<Method>
				<name="automaticallyNotifiesObservers">
				<signature="func automaticallyNotifiesObservers(for: Swift.AnyKeyPath) -> Bool">
				<isStatic="False">
			</Method>
			<Method>
				<name="keyPathsAffectingValue">
				<signature="func keyPathsAffectingValue(for: Swift.AnyKeyPath) -> Swift.Set(Swift.AnyKeyPath)">
				<isStatic="False">
			</Method>
		</Protocol>
		<Protocol name="Foundation.RecoverableError">
			<Method>
				<name="attemptRecovery">
				<signature="func attemptRecovery(optionIndex: Int, resultHandler: Bool)">
				<isStatic="False">
			</Method>
			<Method>
				<name="attemptRecovery">
				<signature="func attemptRecovery(optionIndex: Int) -> Bool">
				<isStatic="False">
			</Method>
			<Method>
				<name="recoveryOptions">
				<signature="func recoveryOptions() -> Swift.Array(Swift.String)">
				<isStatic="False">
			</Method>
		</Protocol>
		<Protocol name="Foundation.ReferenceConvertible">
		</Protocol>
	</Protocols>
</Module>
